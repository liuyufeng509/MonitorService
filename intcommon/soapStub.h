/* soapStub.h
   Generated by gSOAP 2.8.30 for BaseInterface.h

gSOAP XML Web services tools
Copyright (C) 2000-2016, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#include <vector>
#define SOAP_NAMESPACE_OF_ns1	"http://servlet.manage.haibo.com"
#define SOAP_NAMESPACE_OF_nsCXF	"http://servlet.webservice.skynet.botech.com/"

#ifndef soapStub_H
#define soapStub_H
#include "stdsoap2.h"
#if GSOAP_VERSION != 20830
# error "GSOAP VERSION 20830 MISMATCH IN GENERATED CODE VERSUS LIBRARY CODE: PLEASE REINSTALL PACKAGE"
#endif


/******************************************************************************\
 *                                                                            *
 * Types with Custom Serializers                                              *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Classes, Structs and Unions                                                *
 *                                                                            *
\******************************************************************************/

struct ns__Response;	/* BaseInterface.h:19 */
struct ns__HBNET_VIDEO_STREAM;	/* BaseInterface.h:26 */
struct ns__HBNET_VIDEO_STREAM_RESP;	/* BaseInterface.h:33 */
struct ns__HBNET_CAMERA_PTZCTRL;	/* BaseInterface.h:40 */
struct ns__HBNET_RECOED_PLAYCTRL;	/* BaseInterface.h:50 */
struct ns__HBNET_RECOED_FILECOND;	/* BaseInterface.h:57 */
struct ns__HBNET_CAMREA_INFO;	/* BaseInterface.h:65 */
struct ns__HBUSERINFO;	/* BaseInterface.h:74 */
struct ns_HeartBeat;	/* BaseInterface.h:81 */
struct ns__SwitchCameraToStream;	/* BaseInterface.h:89 */
struct ns__PTZCtrlCamera;	/* BaseInterface.h:92 */
struct ns__AbandonCameraStream;	/* BaseInterface.h:95 */
struct ns__QueryVideoRecordResponse;	/* BaseInterface.h:98 */
struct ns__QueryVideoRecord;	/* BaseInterface.h:98 */
struct ns__PlayVideoRecord;	/* BaseInterface.h:101 */
struct ns__DownloadVideoRecordResponse;	/* BaseInterface.h:104 */
struct ns__DownloadVideoRecord;	/* BaseInterface.h:104 */
struct ns__AbandonVideoRecord;	/* BaseInterface.h:107 */
struct ns__HeartBeat;	/* BaseInterface.h:110 */
struct ns__AutoSysUpdate;	/* BaseInterface.h:113 */
struct ns__NetMasterResponse;	/* BaseInterface.h:116 */
struct ns__NetMaster;	/* BaseInterface.h:116 */
struct ns__HBOperateResponse;	/* BaseInterface.h:119 */
struct ns__HBOperate;	/* BaseInterface.h:119 */
class _ns1__getData;	/* BaseInterface.h:132 */
class _ns1__getDataResponse;	/* BaseInterface.h:135 */
struct __ns1__getData;	/* BaseInterface.h:175 */
class nsCXF__getDataCxf;	/* BaseInterface.h:190 */
class nsCXF__getDataCxfResponse;	/* BaseInterface.h:193 */
struct __nsCXF__getDataCxf;	/* BaseInterface.h:229 */

/* BaseInterface.h:19 */
#ifndef SOAP_TYPE_ns__Response
#define SOAP_TYPE_ns__Response (9)
/* complex XSD type 'ns:Response': */
struct ns__Response {
      public:
        /** Required element 'retcode' of XSD type 'xsd:int' */
        int retcode;
        /** Required element 'strMessage' of XSD type 'xsd:string' */
        std::string strMessage;
      public:
        /** Return unique type id SOAP_TYPE_ns__Response */
        int soap_type() const { return SOAP_TYPE_ns__Response; }
        /** Constructor with member initializations */
        ns__Response()
        {
          retcode = (int)0;
        }
        /** Friend allocator used by soap_new_ns__Response(struct soap*, int) */
        friend SOAP_FMAC1 ns__Response * SOAP_FMAC2 soap_instantiate_ns__Response(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* BaseInterface.h:26 */
#ifndef SOAP_TYPE_ns__HBNET_VIDEO_STREAM
#define SOAP_TYPE_ns__HBNET_VIDEO_STREAM (11)
/* complex XSD type 'ns:HBNET-VIDEO-STREAM': */
struct ns__HBNET_VIDEO_STREAM {
      public:
        /** Required element 'vsfStreamType' of XSD type 'xsd:int' */
        int vsfStreamType;
        /** Optional element 'szDescription' of XSD type 'xsd:string' */
        char *szDescription;
      public:
        /** Return unique type id SOAP_TYPE_ns__HBNET_VIDEO_STREAM */
        int soap_type() const { return SOAP_TYPE_ns__HBNET_VIDEO_STREAM; }
        /** Constructor with member initializations */
        ns__HBNET_VIDEO_STREAM()
        {
          vsfStreamType = (int)0;
          szDescription = (char *)0;
        }
        /** Friend allocator used by soap_new_ns__HBNET_VIDEO_STREAM(struct soap*, int) */
        friend SOAP_FMAC1 ns__HBNET_VIDEO_STREAM * SOAP_FMAC2 soap_instantiate_ns__HBNET_VIDEO_STREAM(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* BaseInterface.h:33 */
#ifndef SOAP_TYPE_ns__HBNET_VIDEO_STREAM_RESP
#define SOAP_TYPE_ns__HBNET_VIDEO_STREAM_RESP (12)
/* complex XSD type 'ns:HBNET-VIDEO-STREAM-RESP': */
struct ns__HBNET_VIDEO_STREAM_RESP {
      public:
        /** Required element 'vsfStreamType' of XSD type 'xsd:int' */
        int vsfStreamType;
        /** Optional element 'szDescription' of XSD type 'xsd:string' */
        char *szDescription;
      public:
        /** Return unique type id SOAP_TYPE_ns__HBNET_VIDEO_STREAM_RESP */
        int soap_type() const { return SOAP_TYPE_ns__HBNET_VIDEO_STREAM_RESP; }
        /** Constructor with member initializations */
        ns__HBNET_VIDEO_STREAM_RESP()
        {
          vsfStreamType = (int)0;
          szDescription = (char *)0;
        }
        /** Friend allocator used by soap_new_ns__HBNET_VIDEO_STREAM_RESP(struct soap*, int) */
        friend SOAP_FMAC1 ns__HBNET_VIDEO_STREAM_RESP * SOAP_FMAC2 soap_instantiate_ns__HBNET_VIDEO_STREAM_RESP(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* BaseInterface.h:40 */
#ifndef SOAP_TYPE_ns__HBNET_CAMERA_PTZCTRL
#define SOAP_TYPE_ns__HBNET_CAMERA_PTZCTRL (13)
/* complex XSD type 'ns:HBNET-CAMERA-PTZCTRL': */
struct ns__HBNET_CAMERA_PTZCTRL {
      public:
        /** Required element 'ulCamNumber' of XSD type 'xsd:unsignedLong' */
        unsigned long ulCamNumber;
        /** Required element 'ulVS1' of XSD type 'xsd:unsignedLong' */
        unsigned long ulVS1;
        /** Required element 'ulVS2' of XSD type 'xsd:unsignedLong' */
        unsigned long ulVS2;
        /** Required element 'ulVS3' of XSD type 'xsd:unsignedLong' */
        unsigned long ulVS3;
        /** Required element 'ulVS4' of XSD type 'xsd:unsignedLong' */
        unsigned long ulVS4;
      public:
        /** Return unique type id SOAP_TYPE_ns__HBNET_CAMERA_PTZCTRL */
        int soap_type() const { return SOAP_TYPE_ns__HBNET_CAMERA_PTZCTRL; }
        /** Constructor with member initializations */
        ns__HBNET_CAMERA_PTZCTRL()
        {
          ulCamNumber = (unsigned long)0;
          ulVS1 = (unsigned long)0;
          ulVS2 = (unsigned long)0;
          ulVS3 = (unsigned long)0;
          ulVS4 = (unsigned long)0;
        }
        /** Friend allocator used by soap_new_ns__HBNET_CAMERA_PTZCTRL(struct soap*, int) */
        friend SOAP_FMAC1 ns__HBNET_CAMERA_PTZCTRL * SOAP_FMAC2 soap_instantiate_ns__HBNET_CAMERA_PTZCTRL(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* BaseInterface.h:50 */
#ifndef SOAP_TYPE_ns__HBNET_RECOED_PLAYCTRL
#define SOAP_TYPE_ns__HBNET_RECOED_PLAYCTRL (17)
/* complex XSD type 'ns:HBNET-RECOED-PLAYCTRL': */
struct ns__HBNET_RECOED_PLAYCTRL {
      public:
        /** Required element 'ulControlCode' of XSD type 'xsd:unsignedLong' */
        unsigned long ulControlCode;
        /** Required element 'ulInValue' of XSD type 'xsd:unsignedLong' */
        unsigned long ulInValue;
      public:
        /** Return unique type id SOAP_TYPE_ns__HBNET_RECOED_PLAYCTRL */
        int soap_type() const { return SOAP_TYPE_ns__HBNET_RECOED_PLAYCTRL; }
        /** Constructor with member initializations */
        ns__HBNET_RECOED_PLAYCTRL()
        {
          ulControlCode = (unsigned long)0;
          ulInValue = (unsigned long)0;
        }
        /** Friend allocator used by soap_new_ns__HBNET_RECOED_PLAYCTRL(struct soap*, int) */
        friend SOAP_FMAC1 ns__HBNET_RECOED_PLAYCTRL * SOAP_FMAC2 soap_instantiate_ns__HBNET_RECOED_PLAYCTRL(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* BaseInterface.h:57 */
#ifndef SOAP_TYPE_ns__HBNET_RECOED_FILECOND
#define SOAP_TYPE_ns__HBNET_RECOED_FILECOND (18)
/* complex XSD type 'ns:HBNET-RECOED-FILECOND': */
struct ns__HBNET_RECOED_FILECOND {
      public:
        /** Required element 'ulCamNumber' of XSD type 'xsd:unsignedLong' */
        unsigned long ulCamNumber;
        /** Required element 'ulStartTime' of XSD type 'xsd:unsignedLong' */
        unsigned long ulStartTime;
        /** Required element 'ulStopTime' of XSD type 'xsd:unsignedLong' */
        unsigned long ulStopTime;
      public:
        /** Return unique type id SOAP_TYPE_ns__HBNET_RECOED_FILECOND */
        int soap_type() const { return SOAP_TYPE_ns__HBNET_RECOED_FILECOND; }
        /** Constructor with member initializations */
        ns__HBNET_RECOED_FILECOND()
        {
          ulCamNumber = (unsigned long)0;
          ulStartTime = (unsigned long)0;
          ulStopTime = (unsigned long)0;
        }
        /** Friend allocator used by soap_new_ns__HBNET_RECOED_FILECOND(struct soap*, int) */
        friend SOAP_FMAC1 ns__HBNET_RECOED_FILECOND * SOAP_FMAC2 soap_instantiate_ns__HBNET_RECOED_FILECOND(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* BaseInterface.h:65 */
#ifndef SOAP_TYPE_ns__HBNET_CAMREA_INFO
#define SOAP_TYPE_ns__HBNET_CAMREA_INFO (19)
/* complex XSD type 'ns:HBNET-CAMREA-INFO': */
struct ns__HBNET_CAMREA_INFO {
      public:
        /** Required element 'ulCamNumber' of XSD type 'xsd:unsignedLong' */
        unsigned long ulCamNumber;
        /** Required element 'ulCamID' of XSD type 'xsd:unsignedLong' */
        unsigned long ulCamID;
        /** Required element 'ulCamDepartmentID' of XSD type 'xsd:unsignedLong' */
        unsigned long ulCamDepartmentID;
        /** Required element 'strCamName' of XSD type 'xsd:string' */
        std::string strCamName;
      public:
        /** Return unique type id SOAP_TYPE_ns__HBNET_CAMREA_INFO */
        int soap_type() const { return SOAP_TYPE_ns__HBNET_CAMREA_INFO; }
        /** Constructor with member initializations */
        ns__HBNET_CAMREA_INFO()
        {
          ulCamNumber = (unsigned long)0;
          ulCamID = (unsigned long)0;
          ulCamDepartmentID = (unsigned long)0;
        }
        /** Friend allocator used by soap_new_ns__HBNET_CAMREA_INFO(struct soap*, int) */
        friend SOAP_FMAC1 ns__HBNET_CAMREA_INFO * SOAP_FMAC2 soap_instantiate_ns__HBNET_CAMREA_INFO(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* BaseInterface.h:74 */
#ifndef SOAP_TYPE_ns__HBUSERINFO
#define SOAP_TYPE_ns__HBUSERINFO (20)
/* complex XSD type 'ns:HBUSERINFO': */
struct ns__HBUSERINFO {
      public:
        /** Required element 'strUser' of XSD type 'xsd:string' */
        std::string strUser;
        /** Required element 'nPermission' of XSD type 'xsd:int' */
        int nPermission;
        /** Required element 'nCtrlTimeOut' of XSD type 'xsd:int' */
        int nCtrlTimeOut;
      public:
        /** Return unique type id SOAP_TYPE_ns__HBUSERINFO */
        int soap_type() const { return SOAP_TYPE_ns__HBUSERINFO; }
        /** Constructor with member initializations */
        ns__HBUSERINFO()
        {
          nPermission = (int)0;
          nCtrlTimeOut = (int)0;
        }
        /** Friend allocator used by soap_new_ns__HBUSERINFO(struct soap*, int) */
        friend SOAP_FMAC1 ns__HBUSERINFO * SOAP_FMAC2 soap_instantiate_ns__HBUSERINFO(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* BaseInterface.h:81 */
#ifndef SOAP_TYPE_ns_HeartBeat
#define SOAP_TYPE_ns_HeartBeat (21)
/* complex XSD type 'ns-HeartBeat': */
struct ns_HeartBeat {
      public:
        /** Required element 'strUser' of XSD type 'xsd:string' */
        std::string strUser;
        /** Required element 'ulCameraID' of XSD type 'xsd:unsignedLong' */
        unsigned long ulCameraID;
        /** Required element 'nPlayType' of XSD type 'xsd:int' */
        int nPlayType;
        /** Required element 'strFileName' of XSD type 'xsd:string' */
        std::string strFileName;
      public:
        /** Return unique type id SOAP_TYPE_ns_HeartBeat */
        int soap_type() const { return SOAP_TYPE_ns_HeartBeat; }
        /** Constructor with member initializations */
        ns_HeartBeat()
        {
          ulCameraID = (unsigned long)0;
          nPlayType = (int)0;
        }
        /** Friend allocator used by soap_new_ns_HeartBeat(struct soap*, int) */
        friend SOAP_FMAC1 ns_HeartBeat * SOAP_FMAC2 soap_instantiate_ns_HeartBeat(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* BaseInterface.h:89 */
#ifndef SOAP_TYPE_ns__SwitchCameraToStream
#define SOAP_TYPE_ns__SwitchCameraToStream (24)
/* complex XSD type 'ns:SwitchCameraToStream': */
struct ns__SwitchCameraToStream {
      public:
        /** Required element 'nsUserInfo' of XSD type 'ns:HBUSERINFO' */
        struct ns__HBUSERINFO nsUserInfo;
        /** Required element 'CamID' of XSD type 'xsd:long' */
        long CamID;
      public:
        /** Return unique type id SOAP_TYPE_ns__SwitchCameraToStream */
        int soap_type() const { return SOAP_TYPE_ns__SwitchCameraToStream; }
        /** Constructor with member initializations */
        ns__SwitchCameraToStream()
        {
          CamID = (long)0;
        }
        /** Friend allocator used by soap_new_ns__SwitchCameraToStream(struct soap*, int) */
        friend SOAP_FMAC1 ns__SwitchCameraToStream * SOAP_FMAC2 soap_instantiate_ns__SwitchCameraToStream(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* BaseInterface.h:92 */
#ifndef SOAP_TYPE_ns__PTZCtrlCamera
#define SOAP_TYPE_ns__PTZCtrlCamera (28)
/* complex XSD type 'ns:PTZCtrlCamera': */
struct ns__PTZCtrlCamera {
      public:
        /** Required element 'nsUserInfo' of XSD type 'ns:HBUSERINFO' */
        struct ns__HBUSERINFO nsUserInfo;
        /** Required element 'CamID' of XSD type 'xsd:long' */
        long CamID;
        /** Optional element 'Data' of XSD type 'ns:HBNET-CAMERA-PTZCTRL' */
        struct ns__HBNET_CAMERA_PTZCTRL *Data;
      public:
        /** Return unique type id SOAP_TYPE_ns__PTZCtrlCamera */
        int soap_type() const { return SOAP_TYPE_ns__PTZCtrlCamera; }
        /** Constructor with member initializations */
        ns__PTZCtrlCamera()
        {
          CamID = (long)0;
          Data = (struct ns__HBNET_CAMERA_PTZCTRL *)0;
        }
        /** Friend allocator used by soap_new_ns__PTZCtrlCamera(struct soap*, int) */
        friend SOAP_FMAC1 ns__PTZCtrlCamera * SOAP_FMAC2 soap_instantiate_ns__PTZCtrlCamera(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* BaseInterface.h:95 */
#ifndef SOAP_TYPE_ns__AbandonCameraStream
#define SOAP_TYPE_ns__AbandonCameraStream (30)
/* complex XSD type 'ns:AbandonCameraStream': */
struct ns__AbandonCameraStream {
      public:
        /** Required element 'nsUserInfo' of XSD type 'ns:HBUSERINFO' */
        struct ns__HBUSERINFO nsUserInfo;
        /** Required element 'CamID' of XSD type 'xsd:long' */
        long CamID;
      public:
        /** Return unique type id SOAP_TYPE_ns__AbandonCameraStream */
        int soap_type() const { return SOAP_TYPE_ns__AbandonCameraStream; }
        /** Constructor with member initializations */
        ns__AbandonCameraStream()
        {
          CamID = (long)0;
        }
        /** Friend allocator used by soap_new_ns__AbandonCameraStream(struct soap*, int) */
        friend SOAP_FMAC1 ns__AbandonCameraStream * SOAP_FMAC2 soap_instantiate_ns__AbandonCameraStream(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* BaseInterface.h:98 */
#ifndef SOAP_TYPE_ns__QueryVideoRecordResponse
#define SOAP_TYPE_ns__QueryVideoRecordResponse (34)
/* complex XSD type 'ns:QueryVideoRecordResponse': */
struct ns__QueryVideoRecordResponse {
      public:
        /** Required element 'RecodeList' of XSD type 'xsd:string' */
        char *RecodeList;
      public:
        /** Return unique type id SOAP_TYPE_ns__QueryVideoRecordResponse */
        int soap_type() const { return SOAP_TYPE_ns__QueryVideoRecordResponse; }
        /** Constructor with member initializations */
        ns__QueryVideoRecordResponse()
        {
          RecodeList = (char *)0;
        }
        /** Friend allocator used by soap_new_ns__QueryVideoRecordResponse(struct soap*, int) */
        friend SOAP_FMAC1 ns__QueryVideoRecordResponse * SOAP_FMAC2 soap_instantiate_ns__QueryVideoRecordResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* BaseInterface.h:98 */
#ifndef SOAP_TYPE_ns__QueryVideoRecord
#define SOAP_TYPE_ns__QueryVideoRecord (35)
/* complex XSD type 'ns:QueryVideoRecord': */
struct ns__QueryVideoRecord {
      public:
        /** Required element 'nsUserInfo' of XSD type 'ns:HBUSERINFO' */
        struct ns__HBUSERINFO nsUserInfo;
        /** Required element 'CamID' of XSD type 'xsd:long' */
        long CamID;
        /** Optional element 'Param' of XSD type 'ns:HBNET-RECOED-FILECOND' */
        struct ns__HBNET_RECOED_FILECOND *Param;
      public:
        /** Return unique type id SOAP_TYPE_ns__QueryVideoRecord */
        int soap_type() const { return SOAP_TYPE_ns__QueryVideoRecord; }
        /** Constructor with member initializations */
        ns__QueryVideoRecord()
        {
          CamID = (long)0;
          Param = (struct ns__HBNET_RECOED_FILECOND *)0;
        }
        /** Friend allocator used by soap_new_ns__QueryVideoRecord(struct soap*, int) */
        friend SOAP_FMAC1 ns__QueryVideoRecord * SOAP_FMAC2 soap_instantiate_ns__QueryVideoRecord(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* BaseInterface.h:101 */
#ifndef SOAP_TYPE_ns__PlayVideoRecord
#define SOAP_TYPE_ns__PlayVideoRecord (38)
/* complex XSD type 'ns:PlayVideoRecord': */
struct ns__PlayVideoRecord {
      public:
        /** Required element 'nsUserInfo' of XSD type 'ns:HBUSERINFO' */
        struct ns__HBUSERINFO nsUserInfo;
        /** Required element 'CamID' of XSD type 'xsd:long' */
        long CamID;
        /** Optional element 'Data' of XSD type 'ns:HBNET-VIDEO-STREAM' */
        struct ns__HBNET_VIDEO_STREAM *Data;
      public:
        /** Return unique type id SOAP_TYPE_ns__PlayVideoRecord */
        int soap_type() const { return SOAP_TYPE_ns__PlayVideoRecord; }
        /** Constructor with member initializations */
        ns__PlayVideoRecord()
        {
          CamID = (long)0;
          Data = (struct ns__HBNET_VIDEO_STREAM *)0;
        }
        /** Friend allocator used by soap_new_ns__PlayVideoRecord(struct soap*, int) */
        friend SOAP_FMAC1 ns__PlayVideoRecord * SOAP_FMAC2 soap_instantiate_ns__PlayVideoRecord(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* BaseInterface.h:104 */
#ifndef SOAP_TYPE_ns__DownloadVideoRecordResponse
#define SOAP_TYPE_ns__DownloadVideoRecordResponse (40)
/* complex XSD type 'ns:DownloadVideoRecordResponse': */
struct ns__DownloadVideoRecordResponse {
      public:
        /** Required element 'OutFileName' of XSD type 'xsd:string' */
        char *OutFileName;
      public:
        /** Return unique type id SOAP_TYPE_ns__DownloadVideoRecordResponse */
        int soap_type() const { return SOAP_TYPE_ns__DownloadVideoRecordResponse; }
        /** Constructor with member initializations */
        ns__DownloadVideoRecordResponse()
        {
          OutFileName = (char *)0;
        }
        /** Friend allocator used by soap_new_ns__DownloadVideoRecordResponse(struct soap*, int) */
        friend SOAP_FMAC1 ns__DownloadVideoRecordResponse * SOAP_FMAC2 soap_instantiate_ns__DownloadVideoRecordResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* BaseInterface.h:104 */
#ifndef SOAP_TYPE_ns__DownloadVideoRecord
#define SOAP_TYPE_ns__DownloadVideoRecord (41)
/* complex XSD type 'ns:DownloadVideoRecord': */
struct ns__DownloadVideoRecord {
      public:
        /** Required element 'nsUserInfo' of XSD type 'ns:HBUSERINFO' */
        struct ns__HBUSERINFO nsUserInfo;
        /** Required element 'CamID' of XSD type 'xsd:long' */
        long CamID;
        /** Optional element 'szFileName' of XSD type 'xsd:string' */
        char *szFileName;
      public:
        /** Return unique type id SOAP_TYPE_ns__DownloadVideoRecord */
        int soap_type() const { return SOAP_TYPE_ns__DownloadVideoRecord; }
        /** Constructor with member initializations */
        ns__DownloadVideoRecord()
        {
          CamID = (long)0;
          szFileName = (char *)0;
        }
        /** Friend allocator used by soap_new_ns__DownloadVideoRecord(struct soap*, int) */
        friend SOAP_FMAC1 ns__DownloadVideoRecord * SOAP_FMAC2 soap_instantiate_ns__DownloadVideoRecord(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* BaseInterface.h:107 */
#ifndef SOAP_TYPE_ns__AbandonVideoRecord
#define SOAP_TYPE_ns__AbandonVideoRecord (43)
/* complex XSD type 'ns:AbandonVideoRecord': */
struct ns__AbandonVideoRecord {
      public:
        /** Required element 'nsUserInfo' of XSD type 'ns:HBUSERINFO' */
        struct ns__HBUSERINFO nsUserInfo;
        /** Required element 'CamID' of XSD type 'xsd:long' */
        long CamID;
        /** Optional element 'FileName' of XSD type 'xsd:string' */
        char *FileName;
      public:
        /** Return unique type id SOAP_TYPE_ns__AbandonVideoRecord */
        int soap_type() const { return SOAP_TYPE_ns__AbandonVideoRecord; }
        /** Constructor with member initializations */
        ns__AbandonVideoRecord()
        {
          CamID = (long)0;
          FileName = (char *)0;
        }
        /** Friend allocator used by soap_new_ns__AbandonVideoRecord(struct soap*, int) */
        friend SOAP_FMAC1 ns__AbandonVideoRecord * SOAP_FMAC2 soap_instantiate_ns__AbandonVideoRecord(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* BaseInterface.h:110 */
#ifndef SOAP_TYPE_ns__HeartBeat
#define SOAP_TYPE_ns__HeartBeat (45)
/* complex XSD type 'ns:HeartBeat': */
struct ns__HeartBeat {
      public:
        /** Required element 'nsHeartBeat' of XSD type 'ns-HeartBeat' */
        struct ns_HeartBeat nsHeartBeat;
      public:
        /** Return unique type id SOAP_TYPE_ns__HeartBeat */
        int soap_type() const { return SOAP_TYPE_ns__HeartBeat; }
        /** Constructor with member initializations */
        ns__HeartBeat()
        {
        }
        /** Friend allocator used by soap_new_ns__HeartBeat(struct soap*, int) */
        friend SOAP_FMAC1 ns__HeartBeat * SOAP_FMAC2 soap_instantiate_ns__HeartBeat(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* BaseInterface.h:113 */
#ifndef SOAP_TYPE_ns__AutoSysUpdate
#define SOAP_TYPE_ns__AutoSysUpdate (47)
/* complex XSD type 'ns:AutoSysUpdate': */
struct ns__AutoSysUpdate {
      public:
        /** Required element 'strXmlFile' of XSD type 'xsd:string' */
        std::string strXmlFile;
      public:
        /** Return unique type id SOAP_TYPE_ns__AutoSysUpdate */
        int soap_type() const { return SOAP_TYPE_ns__AutoSysUpdate; }
        /** Constructor with member initializations */
        ns__AutoSysUpdate()
        {
        }
        /** Friend allocator used by soap_new_ns__AutoSysUpdate(struct soap*, int) */
        friend SOAP_FMAC1 ns__AutoSysUpdate * SOAP_FMAC2 soap_instantiate_ns__AutoSysUpdate(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* BaseInterface.h:116 */
#ifndef SOAP_TYPE_ns__NetMasterResponse
#define SOAP_TYPE_ns__NetMasterResponse (50)
/* complex XSD type 'ns:NetMasterResponse': */
struct ns__NetMasterResponse {
      public:
        /** Required element 'nResult' of XSD type 'xsd:int' */
        int nResult;
      public:
        /** Return unique type id SOAP_TYPE_ns__NetMasterResponse */
        int soap_type() const { return SOAP_TYPE_ns__NetMasterResponse; }
        /** Constructor with member initializations */
        ns__NetMasterResponse()
        {
          nResult = (int)0;
        }
        /** Friend allocator used by soap_new_ns__NetMasterResponse(struct soap*, int) */
        friend SOAP_FMAC1 ns__NetMasterResponse * SOAP_FMAC2 soap_instantiate_ns__NetMasterResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* BaseInterface.h:116 */
#ifndef SOAP_TYPE_ns__NetMaster
#define SOAP_TYPE_ns__NetMaster (51)
/* complex XSD type 'ns:NetMaster': */
struct ns__NetMaster {
      public:
        /** Required element 'nIsOK' of XSD type 'xsd:int' */
        int nIsOK;
      public:
        /** Return unique type id SOAP_TYPE_ns__NetMaster */
        int soap_type() const { return SOAP_TYPE_ns__NetMaster; }
        /** Constructor with member initializations */
        ns__NetMaster()
        {
          nIsOK = (int)0;
        }
        /** Friend allocator used by soap_new_ns__NetMaster(struct soap*, int) */
        friend SOAP_FMAC1 ns__NetMaster * SOAP_FMAC2 soap_instantiate_ns__NetMaster(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* BaseInterface.h:119 */
#ifndef SOAP_TYPE_ns__HBOperateResponse
#define SOAP_TYPE_ns__HBOperateResponse (53)
/* complex XSD type 'ns:HBOperateResponse': */
struct ns__HBOperateResponse {
      public:
        /** Required element 'szXmlRes' of XSD type 'xsd:string' */
        char *szXmlRes;
      public:
        /** Return unique type id SOAP_TYPE_ns__HBOperateResponse */
        int soap_type() const { return SOAP_TYPE_ns__HBOperateResponse; }
        /** Constructor with member initializations */
        ns__HBOperateResponse()
        {
          szXmlRes = (char *)0;
        }
        /** Friend allocator used by soap_new_ns__HBOperateResponse(struct soap*, int) */
        friend SOAP_FMAC1 ns__HBOperateResponse * SOAP_FMAC2 soap_instantiate_ns__HBOperateResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* BaseInterface.h:119 */
#ifndef SOAP_TYPE_ns__HBOperate
#define SOAP_TYPE_ns__HBOperate (54)
/* complex XSD type 'ns:HBOperate': */
struct ns__HBOperate {
      public:
        /** Optional element 'szXml' of XSD type 'xsd:string' */
        char *szXml;
      public:
        /** Return unique type id SOAP_TYPE_ns__HBOperate */
        int soap_type() const { return SOAP_TYPE_ns__HBOperate; }
        /** Constructor with member initializations */
        ns__HBOperate()
        {
          szXml = (char *)0;
        }
        /** Friend allocator used by soap_new_ns__HBOperate(struct soap*, int) */
        friend SOAP_FMAC1 ns__HBOperate * SOAP_FMAC2 soap_instantiate_ns__HBOperate(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* BaseInterface.h:132 */
#ifndef SOAP_TYPE__ns1__getData
#define SOAP_TYPE__ns1__getData (55)
/* complex XSD type 'ns1:getData': */
class SOAP_CMAC _ns1__getData {
      public:
        /// Required element 'ns1:in0' of XSD type 'xsd:string'
        std::string *in0;
        /// Required element 'ns1:in1' of XSD type 'xsd:string'
        std::string *in1;
        /// Required element 'ns1:in2' of XSD type 'xsd:string'
        std::string *in2;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__getData
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__getData; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__getData, default initialized and not managed by a soap context
        virtual _ns1__getData *soap_alloc(void) const { return SOAP_NEW(_ns1__getData); }
      public:
        /// Constructor with initializations
        _ns1__getData()
        {
          in0 = (std::string *)0;
          in1 = (std::string *)0;
          in2 = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__getData() { }
        /// Friend allocator used by soap_new__ns1__getData(struct soap*, int)
        friend SOAP_FMAC1 _ns1__getData * SOAP_FMAC2 soap_instantiate__ns1__getData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* BaseInterface.h:135 */
#ifndef SOAP_TYPE__ns1__getDataResponse
#define SOAP_TYPE__ns1__getDataResponse (56)
/* complex XSD type 'ns1:getDataResponse': */
class SOAP_CMAC _ns1__getDataResponse {
      public:
        /// Required element 'ns1:out' of XSD type 'xsd:string'
        std::string *out;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__getDataResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__getDataResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__getDataResponse, default initialized and not managed by a soap context
        virtual _ns1__getDataResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__getDataResponse); }
      public:
        /// Constructor with initializations
        _ns1__getDataResponse()
        {
          out = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__getDataResponse() { }
        /// Friend allocator used by soap_new__ns1__getDataResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__getDataResponse * SOAP_FMAC2 soap_instantiate__ns1__getDataResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* BaseInterface.h:175 */
#ifndef SOAP_TYPE___ns1__getData
#define SOAP_TYPE___ns1__getData (62)
/* Wrapper: */
struct __ns1__getData {
      public:
        /** Optional element 'ns1:getData' of XSD type 'ns1:getData' */
        _ns1__getData *ns1__getData;
      public:
        /** Return unique type id SOAP_TYPE___ns1__getData */
        int soap_type() const { return SOAP_TYPE___ns1__getData; }
        /** Constructor with member initializations */
        __ns1__getData()
        {
          ns1__getData = (_ns1__getData *)0;
        }
        /** Friend allocator used by soap_new___ns1__getData(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__getData * SOAP_FMAC2 soap_instantiate___ns1__getData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* BaseInterface.h:190 */
#ifndef SOAP_TYPE_nsCXF__getDataCxf
#define SOAP_TYPE_nsCXF__getDataCxf (63)
/* complex XSD type 'nsCXF:getDataCxf': */
class SOAP_CMAC nsCXF__getDataCxf {
      public:
        /// Optional element 'arg0' of XSD type 'xsd:string'
        std::string *arg0;
        /// Optional element 'arg1' of XSD type 'xsd:string'
        std::string *arg1;
        /// Optional element 'arg2' of XSD type 'xsd:string'
        std::string *arg2;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_nsCXF__getDataCxf
        virtual int soap_type(void) const { return SOAP_TYPE_nsCXF__getDataCxf; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type nsCXF__getDataCxf, default initialized and not managed by a soap context
        virtual nsCXF__getDataCxf *soap_alloc(void) const { return SOAP_NEW(nsCXF__getDataCxf); }
      public:
        /// Constructor with initializations
        nsCXF__getDataCxf()
        {
          arg0 = (std::string *)0;
          arg1 = (std::string *)0;
          arg2 = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~nsCXF__getDataCxf() { }
        /// Friend allocator used by soap_new_nsCXF__getDataCxf(struct soap*, int)
        friend SOAP_FMAC1 nsCXF__getDataCxf * SOAP_FMAC2 soap_instantiate_nsCXF__getDataCxf(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* BaseInterface.h:193 */
#ifndef SOAP_TYPE_nsCXF__getDataCxfResponse
#define SOAP_TYPE_nsCXF__getDataCxfResponse (64)
/* complex XSD type 'nsCXF:getDataCxfResponse': */
class SOAP_CMAC nsCXF__getDataCxfResponse {
      public:
        /// Optional element 'return' of XSD type 'xsd:string'
        std::string *return_;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_nsCXF__getDataCxfResponse
        virtual int soap_type(void) const { return SOAP_TYPE_nsCXF__getDataCxfResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type nsCXF__getDataCxfResponse, default initialized and not managed by a soap context
        virtual nsCXF__getDataCxfResponse *soap_alloc(void) const { return SOAP_NEW(nsCXF__getDataCxfResponse); }
      public:
        /// Constructor with initializations
        nsCXF__getDataCxfResponse()
        {
          return_ = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~nsCXF__getDataCxfResponse() { }
        /// Friend allocator used by soap_new_nsCXF__getDataCxfResponse(struct soap*, int)
        friend SOAP_FMAC1 nsCXF__getDataCxfResponse * SOAP_FMAC2 soap_instantiate_nsCXF__getDataCxfResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* BaseInterface.h:229 */
#ifndef SOAP_TYPE___nsCXF__getDataCxf
#define SOAP_TYPE___nsCXF__getDataCxf (68)
/* Wrapper: */
struct __nsCXF__getDataCxf {
      public:
        /** Optional element 'nsCXF:getDataCxf' of XSD type 'nsCXF:getDataCxf' */
        nsCXF__getDataCxf *nsCXF__getDataCxf_;
      public:
        /** Return unique type id SOAP_TYPE___nsCXF__getDataCxf */
        int soap_type() const { return SOAP_TYPE___nsCXF__getDataCxf; }
        /** Constructor with member initializations */
        __nsCXF__getDataCxf()
        {
          nsCXF__getDataCxf_ = (nsCXF__getDataCxf *)0;
        }
        /** Friend allocator used by soap_new___nsCXF__getDataCxf(struct soap*, int) */
        friend SOAP_FMAC1 __nsCXF__getDataCxf * SOAP_FMAC2 soap_instantiate___nsCXF__getDataCxf(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* BaseInterface.h:230 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (69)
/* SOAP_ENV__Header: */
struct SOAP_ENV__Header {
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Header */
        int soap_type() const { return SOAP_TYPE_SOAP_ENV__Header; }
        /** Constructor with member initializations */
        SOAP_ENV__Header()
        {
        }
        /** Friend allocator used by soap_new_SOAP_ENV__Header(struct soap*, int) */
        friend SOAP_FMAC1 SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* BaseInterface.h:230 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (70)
/* Type SOAP_ENV__Code is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* SOAP_ENV__Code: */
struct SOAP_ENV__Code {
      public:
        /** Optional element 'SOAP-ENV:Value' of XSD type 'xsd:QName' */
        char *SOAP_ENV__Value;
        /** Optional element 'SOAP-ENV:Subcode' of XSD type 'SOAP-ENV:Code' */
        struct SOAP_ENV__Code *SOAP_ENV__Subcode;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Code */
        int soap_type() const { return SOAP_TYPE_SOAP_ENV__Code; }
        /** Constructor with member initializations */
        SOAP_ENV__Code()
        {
          SOAP_ENV__Value = (char *)0;
          SOAP_ENV__Subcode = (struct SOAP_ENV__Code *)0;
        }
        /** Friend allocator used by soap_new_SOAP_ENV__Code(struct soap*, int) */
        friend SOAP_FMAC1 SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* BaseInterface.h:230 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (72)
/* SOAP_ENV__Detail: */
struct SOAP_ENV__Detail {
      public:
        char *__any;
        /** Any type of element 'fault' assigned to fault with its SOAP_TYPE_T assigned to __type */
        /** Do not create a cyclic data structure throught this member unless SOAP encoding or SOAP_XML_GRAPH are used for id-ref serialization */
        int __type;
        void *fault;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Detail */
        int soap_type() const { return SOAP_TYPE_SOAP_ENV__Detail; }
        /** Constructor with member initializations */
        SOAP_ENV__Detail()
        {
          __any = (char *)0;
          __type = 0;
          fault = NULL;
        }
        /** Friend allocator used by soap_new_SOAP_ENV__Detail(struct soap*, int) */
        friend SOAP_FMAC1 SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* BaseInterface.h:230 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (75)
/* SOAP_ENV__Reason: */
struct SOAP_ENV__Reason {
      public:
        /** Optional element 'SOAP-ENV:Text' of XSD type 'xsd:string' */
        char *SOAP_ENV__Text;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Reason */
        int soap_type() const { return SOAP_TYPE_SOAP_ENV__Reason; }
        /** Constructor with member initializations */
        SOAP_ENV__Reason()
        {
          SOAP_ENV__Text = (char *)0;
        }
        /** Friend allocator used by soap_new_SOAP_ENV__Reason(struct soap*, int) */
        friend SOAP_FMAC1 SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* BaseInterface.h:230 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (76)
/* SOAP_ENV__Fault: */
struct SOAP_ENV__Fault {
      public:
        /** Optional element 'faultcode' of XSD type 'xsd:QName' */
        char *faultcode;
        /** Optional element 'faultstring' of XSD type 'xsd:string' */
        char *faultstring;
        /** Optional element 'faultactor' of XSD type 'xsd:string' */
        char *faultactor;
        /** Optional element 'detail' of XSD type 'SOAP-ENV:Detail' */
        struct SOAP_ENV__Detail *detail;
        /** Optional element 'SOAP-ENV:Code' of XSD type 'SOAP-ENV:Code' */
        struct SOAP_ENV__Code *SOAP_ENV__Code;
        /** Optional element 'SOAP-ENV:Reason' of XSD type 'SOAP-ENV:Reason' */
        struct SOAP_ENV__Reason *SOAP_ENV__Reason;
        /** Optional element 'SOAP-ENV:Node' of XSD type 'xsd:string' */
        char *SOAP_ENV__Node;
        /** Optional element 'SOAP-ENV:Role' of XSD type 'xsd:string' */
        char *SOAP_ENV__Role;
        /** Optional element 'SOAP-ENV:Detail' of XSD type 'SOAP-ENV:Detail' */
        struct SOAP_ENV__Detail *SOAP_ENV__Detail;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Fault */
        int soap_type() const { return SOAP_TYPE_SOAP_ENV__Fault; }
        /** Constructor with member initializations */
        SOAP_ENV__Fault()
        {
          faultcode = (char *)0;
          faultstring = (char *)0;
          faultactor = (char *)0;
          detail = (struct SOAP_ENV__Detail *)0;
          SOAP_ENV__Code = (struct SOAP_ENV__Code *)0;
          SOAP_ENV__Reason = (struct SOAP_ENV__Reason *)0;
          SOAP_ENV__Node = (char *)0;
          SOAP_ENV__Role = (char *)0;
          SOAP_ENV__Detail = (struct SOAP_ENV__Detail *)0;
        }
        /** Friend allocator used by soap_new_SOAP_ENV__Fault(struct soap*, int) */
        friend SOAP_FMAC1 SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/******************************************************************************\
 *                                                                            *
 * Typedefs                                                                   *
 *                                                                            *
\******************************************************************************/


/* stlvector.h:53 */
#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (5)
typedef char *_QName;
#endif

/* stlvector.h:53 */
#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (6)
typedef char *_XML;
#endif

/* BaseInterface.h:11 */
#ifndef SOAP_TYPE__xsd__schema
#define SOAP_TYPE__xsd__schema (8)
typedef _XML _xsd__schema;
#endif

/******************************************************************************\
 *                                                                            *
 * Serializable Types                                                         *
 *                                                                            *
\******************************************************************************/


/* char has binding name 'byte' for type 'xsd:byte' */
#ifndef SOAP_TYPE_byte
#define SOAP_TYPE_byte (3)
#endif

/* int has binding name 'int' for type 'xsd:int' */
#ifndef SOAP_TYPE_int
#define SOAP_TYPE_int (1)
#endif

/* long has binding name 'long' for type 'xsd:long' */
#ifndef SOAP_TYPE_long
#define SOAP_TYPE_long (15)
#endif

/* unsigned int has binding name 'unsignedInt' for type 'xsd:unsignedInt' */
#ifndef SOAP_TYPE_unsignedInt
#define SOAP_TYPE_unsignedInt (14)
#endif

/* unsigned long has binding name 'unsignedLong' for type 'xsd:unsignedLong' */
#ifndef SOAP_TYPE_unsignedLong
#define SOAP_TYPE_unsignedLong (16)
#endif

/* nsCXF__getDataCxfResponse has binding name 'nsCXF__getDataCxfResponse' for type 'nsCXF:getDataCxfResponse' */
#ifndef SOAP_TYPE_nsCXF__getDataCxfResponse
#define SOAP_TYPE_nsCXF__getDataCxfResponse (64)
#endif

/* nsCXF__getDataCxf has binding name 'nsCXF__getDataCxf' for type 'nsCXF:getDataCxf' */
#ifndef SOAP_TYPE_nsCXF__getDataCxf
#define SOAP_TYPE_nsCXF__getDataCxf (63)
#endif

/* _ns1__getDataResponse has binding name '_ns1__getDataResponse' for type '' */
#ifndef SOAP_TYPE__ns1__getDataResponse
#define SOAP_TYPE__ns1__getDataResponse (56)
#endif

/* _ns1__getData has binding name '_ns1__getData' for type '' */
#ifndef SOAP_TYPE__ns1__getData
#define SOAP_TYPE__ns1__getData (55)
#endif

/* std::string has binding name 'std__string' for type 'xsd:string' */
#ifndef SOAP_TYPE_std__string
#define SOAP_TYPE_std__string (10)
#endif

/* struct SOAP_ENV__Fault has binding name 'SOAP_ENV__Fault' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (76)
#endif

/* struct SOAP_ENV__Reason has binding name 'SOAP_ENV__Reason' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (75)
#endif

/* struct SOAP_ENV__Detail has binding name 'SOAP_ENV__Detail' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (72)
#endif

/* struct SOAP_ENV__Code has binding name 'SOAP_ENV__Code' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (70)
#endif

/* struct SOAP_ENV__Header has binding name 'SOAP_ENV__Header' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (69)
#endif

/* struct ns__HBOperate has binding name 'ns__HBOperate' for type 'ns:HBOperate' */
#ifndef SOAP_TYPE_ns__HBOperate
#define SOAP_TYPE_ns__HBOperate (54)
#endif

/* struct ns__HBOperateResponse has binding name 'ns__HBOperateResponse' for type 'ns:HBOperateResponse' */
#ifndef SOAP_TYPE_ns__HBOperateResponse
#define SOAP_TYPE_ns__HBOperateResponse (53)
#endif

/* struct ns__NetMaster has binding name 'ns__NetMaster' for type 'ns:NetMaster' */
#ifndef SOAP_TYPE_ns__NetMaster
#define SOAP_TYPE_ns__NetMaster (51)
#endif

/* struct ns__NetMasterResponse has binding name 'ns__NetMasterResponse' for type 'ns:NetMasterResponse' */
#ifndef SOAP_TYPE_ns__NetMasterResponse
#define SOAP_TYPE_ns__NetMasterResponse (50)
#endif

/* struct ns__AutoSysUpdate has binding name 'ns__AutoSysUpdate' for type 'ns:AutoSysUpdate' */
#ifndef SOAP_TYPE_ns__AutoSysUpdate
#define SOAP_TYPE_ns__AutoSysUpdate (47)
#endif

/* struct ns__HeartBeat has binding name 'ns__HeartBeat' for type 'ns:HeartBeat' */
#ifndef SOAP_TYPE_ns__HeartBeat
#define SOAP_TYPE_ns__HeartBeat (45)
#endif

/* struct ns__AbandonVideoRecord has binding name 'ns__AbandonVideoRecord' for type 'ns:AbandonVideoRecord' */
#ifndef SOAP_TYPE_ns__AbandonVideoRecord
#define SOAP_TYPE_ns__AbandonVideoRecord (43)
#endif

/* struct ns__DownloadVideoRecord has binding name 'ns__DownloadVideoRecord' for type 'ns:DownloadVideoRecord' */
#ifndef SOAP_TYPE_ns__DownloadVideoRecord
#define SOAP_TYPE_ns__DownloadVideoRecord (41)
#endif

/* struct ns__DownloadVideoRecordResponse has binding name 'ns__DownloadVideoRecordResponse' for type 'ns:DownloadVideoRecordResponse' */
#ifndef SOAP_TYPE_ns__DownloadVideoRecordResponse
#define SOAP_TYPE_ns__DownloadVideoRecordResponse (40)
#endif

/* struct ns__PlayVideoRecord has binding name 'ns__PlayVideoRecord' for type 'ns:PlayVideoRecord' */
#ifndef SOAP_TYPE_ns__PlayVideoRecord
#define SOAP_TYPE_ns__PlayVideoRecord (38)
#endif

/* struct ns__QueryVideoRecord has binding name 'ns__QueryVideoRecord' for type 'ns:QueryVideoRecord' */
#ifndef SOAP_TYPE_ns__QueryVideoRecord
#define SOAP_TYPE_ns__QueryVideoRecord (35)
#endif

/* struct ns__QueryVideoRecordResponse has binding name 'ns__QueryVideoRecordResponse' for type 'ns:QueryVideoRecordResponse' */
#ifndef SOAP_TYPE_ns__QueryVideoRecordResponse
#define SOAP_TYPE_ns__QueryVideoRecordResponse (34)
#endif

/* struct ns__AbandonCameraStream has binding name 'ns__AbandonCameraStream' for type 'ns:AbandonCameraStream' */
#ifndef SOAP_TYPE_ns__AbandonCameraStream
#define SOAP_TYPE_ns__AbandonCameraStream (30)
#endif

/* struct ns__PTZCtrlCamera has binding name 'ns__PTZCtrlCamera' for type 'ns:PTZCtrlCamera' */
#ifndef SOAP_TYPE_ns__PTZCtrlCamera
#define SOAP_TYPE_ns__PTZCtrlCamera (28)
#endif

/* struct ns__SwitchCameraToStream has binding name 'ns__SwitchCameraToStream' for type 'ns:SwitchCameraToStream' */
#ifndef SOAP_TYPE_ns__SwitchCameraToStream
#define SOAP_TYPE_ns__SwitchCameraToStream (24)
#endif

/* struct ns_HeartBeat has binding name 'ns_HeartBeat' for type 'ns-HeartBeat' */
#ifndef SOAP_TYPE_ns_HeartBeat
#define SOAP_TYPE_ns_HeartBeat (21)
#endif

/* struct ns__HBUSERINFO has binding name 'ns__HBUSERINFO' for type 'ns:HBUSERINFO' */
#ifndef SOAP_TYPE_ns__HBUSERINFO
#define SOAP_TYPE_ns__HBUSERINFO (20)
#endif

/* struct ns__HBNET_CAMREA_INFO has binding name 'ns__HBNET_CAMREA_INFO' for type 'ns:HBNET-CAMREA-INFO' */
#ifndef SOAP_TYPE_ns__HBNET_CAMREA_INFO
#define SOAP_TYPE_ns__HBNET_CAMREA_INFO (19)
#endif

/* struct ns__HBNET_RECOED_FILECOND has binding name 'ns__HBNET_RECOED_FILECOND' for type 'ns:HBNET-RECOED-FILECOND' */
#ifndef SOAP_TYPE_ns__HBNET_RECOED_FILECOND
#define SOAP_TYPE_ns__HBNET_RECOED_FILECOND (18)
#endif

/* struct ns__HBNET_RECOED_PLAYCTRL has binding name 'ns__HBNET_RECOED_PLAYCTRL' for type 'ns:HBNET-RECOED-PLAYCTRL' */
#ifndef SOAP_TYPE_ns__HBNET_RECOED_PLAYCTRL
#define SOAP_TYPE_ns__HBNET_RECOED_PLAYCTRL (17)
#endif

/* struct ns__HBNET_CAMERA_PTZCTRL has binding name 'ns__HBNET_CAMERA_PTZCTRL' for type 'ns:HBNET-CAMERA-PTZCTRL' */
#ifndef SOAP_TYPE_ns__HBNET_CAMERA_PTZCTRL
#define SOAP_TYPE_ns__HBNET_CAMERA_PTZCTRL (13)
#endif

/* struct ns__HBNET_VIDEO_STREAM_RESP has binding name 'ns__HBNET_VIDEO_STREAM_RESP' for type 'ns:HBNET-VIDEO-STREAM-RESP' */
#ifndef SOAP_TYPE_ns__HBNET_VIDEO_STREAM_RESP
#define SOAP_TYPE_ns__HBNET_VIDEO_STREAM_RESP (12)
#endif

/* struct ns__HBNET_VIDEO_STREAM has binding name 'ns__HBNET_VIDEO_STREAM' for type 'ns:HBNET-VIDEO-STREAM' */
#ifndef SOAP_TYPE_ns__HBNET_VIDEO_STREAM
#define SOAP_TYPE_ns__HBNET_VIDEO_STREAM (11)
#endif

/* struct ns__Response has binding name 'ns__Response' for type 'ns:Response' */
#ifndef SOAP_TYPE_ns__Response
#define SOAP_TYPE_ns__Response (9)
#endif

/* struct SOAP_ENV__Reason * has binding name 'PointerToSOAP_ENV__Reason' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Reason
#define SOAP_TYPE_PointerToSOAP_ENV__Reason (78)
#endif

/* struct SOAP_ENV__Detail * has binding name 'PointerToSOAP_ENV__Detail' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Detail
#define SOAP_TYPE_PointerToSOAP_ENV__Detail (77)
#endif

/* struct SOAP_ENV__Code * has binding name 'PointerToSOAP_ENV__Code' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Code
#define SOAP_TYPE_PointerToSOAP_ENV__Code (71)
#endif

/* nsCXF__getDataCxfResponse * has binding name 'PointerTonsCXF__getDataCxfResponse' for type 'nsCXF:getDataCxfResponse' */
#ifndef SOAP_TYPE_PointerTonsCXF__getDataCxfResponse
#define SOAP_TYPE_PointerTonsCXF__getDataCxfResponse (66)
#endif

/* nsCXF__getDataCxf * has binding name 'PointerTonsCXF__getDataCxf' for type 'nsCXF:getDataCxf' */
#ifndef SOAP_TYPE_PointerTonsCXF__getDataCxf
#define SOAP_TYPE_PointerTonsCXF__getDataCxf (65)
#endif

/* _ns1__getDataResponse * has binding name 'PointerTo_ns1__getDataResponse' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__getDataResponse
#define SOAP_TYPE_PointerTo_ns1__getDataResponse (60)
#endif

/* _ns1__getData * has binding name 'PointerTo_ns1__getData' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__getData
#define SOAP_TYPE_PointerTo_ns1__getData (59)
#endif

/* std::string * has binding name 'PointerTostd__string' for type 'xsd:string' */
#ifndef SOAP_TYPE_PointerTostd__string
#define SOAP_TYPE_PointerTostd__string (57)
#endif

/* struct ns__HBNET_VIDEO_STREAM_RESP * has binding name 'PointerTons__HBNET_VIDEO_STREAM_RESP' for type 'ns:HBNET-VIDEO-STREAM-RESP' */
#ifndef SOAP_TYPE_PointerTons__HBNET_VIDEO_STREAM_RESP
#define SOAP_TYPE_PointerTons__HBNET_VIDEO_STREAM_RESP (36)
#endif

/* struct ns__HBNET_RECOED_FILECOND * has binding name 'PointerTons__HBNET_RECOED_FILECOND' for type 'ns:HBNET-RECOED-FILECOND' */
#ifndef SOAP_TYPE_PointerTons__HBNET_RECOED_FILECOND
#define SOAP_TYPE_PointerTons__HBNET_RECOED_FILECOND (31)
#endif

/* struct ns__Response * has binding name 'PointerTons__Response' for type 'ns:Response' */
#ifndef SOAP_TYPE_PointerTons__Response
#define SOAP_TYPE_PointerTons__Response (26)
#endif

/* struct ns__HBNET_CAMERA_PTZCTRL * has binding name 'PointerTons__HBNET_CAMERA_PTZCTRL' for type 'ns:HBNET-CAMERA-PTZCTRL' */
#ifndef SOAP_TYPE_PointerTons__HBNET_CAMERA_PTZCTRL
#define SOAP_TYPE_PointerTons__HBNET_CAMERA_PTZCTRL (25)
#endif

/* struct ns__HBNET_VIDEO_STREAM * has binding name 'PointerTons__HBNET_VIDEO_STREAM' for type 'ns:HBNET-VIDEO-STREAM' */
#ifndef SOAP_TYPE_PointerTons__HBNET_VIDEO_STREAM
#define SOAP_TYPE_PointerTons__HBNET_VIDEO_STREAM (22)
#endif

/* _xsd__schema has binding name '_xsd__schema' for type '' */
#ifndef SOAP_TYPE__xsd__schema
#define SOAP_TYPE__xsd__schema (8)
#endif

/* _XML has binding name '_XML' for type '' */
#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (6)
#endif

/* _QName has binding name '_QName' for type 'xsd:QName' */
#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (5)
#endif

/* char * has binding name 'string' for type 'xsd:string' */
#ifndef SOAP_TYPE_string
#define SOAP_TYPE_string (4)
#endif

/******************************************************************************\
 *                                                                            *
 * Externals                                                                  *
 *                                                                            *
\******************************************************************************/


#endif

/* End of soapStub.h */

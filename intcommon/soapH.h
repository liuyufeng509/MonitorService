/* soapH.h
   Generated by gSOAP 2.8.30 for BaseInterface.h

gSOAP XML Web services tools
Copyright (C) 2000-2016, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#ifndef soapH_H
#define soapH_H
#include "soapStub.h"
#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap*, const void*, int);

#ifdef __cplusplus
}
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap*);
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap*);
#endif

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void *SOAP_FMAC4 soap_getelement(struct soap*, int*);
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap*, const void*, const char*, int, int);

#ifdef __cplusplus
}
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap*);

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap);
SOAP_FMAC3 void * SOAP_FMAC4 soap_instantiate(struct soap*, int, const char*, const char*, size_t*);
SOAP_FMAC3 int SOAP_FMAC4 soap_fdelete(struct soap_clist*);
SOAP_FMAC3 int SOAP_FMAC4 soap_fbase(int, int);
SOAP_FMAC3 void SOAP_FMAC4 soap_finsert(struct soap*, int, int, void*, size_t, const void*, void**);

#ifndef SOAP_TYPE_byte_DEFINED
#define SOAP_TYPE_byte_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap*, char *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap*, const char*, int, const char *, const char*);
SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap*, const char*, char *, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap*, const char *, const char*, const char*);

inline int soap_write_byte(struct soap *soap, char const *p)
{	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || soap_put_byte(soap, p, "byte", NULL) || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}
SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap*, char *, const char*, const char*);

inline int soap_read_byte(struct soap *soap, char *p)
{	if (p)
	{	if (soap_begin_recv(soap) || soap_get_byte(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_int_DEFINED
#define SOAP_TYPE_int_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap*, int *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap*, const char*, int, const int *, const char*);
SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap*, const char*, int *, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap*, const int *, const char*, const char*);

inline int soap_write_int(struct soap *soap, int const *p)
{	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || soap_put_int(soap, p, "int", NULL) || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}
SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap*, int *, const char*, const char*);

inline int soap_read_int(struct soap *soap, int *p)
{	if (p)
	{	if (soap_begin_recv(soap) || soap_get_int(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_long_DEFINED
#define SOAP_TYPE_long_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_long(struct soap*, long *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_long(struct soap*, const char*, int, const long *, const char*);
SOAP_FMAC3 long * SOAP_FMAC4 soap_in_long(struct soap*, const char*, long *, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_long(struct soap*, const long *, const char*, const char*);

inline int soap_write_long(struct soap *soap, long const *p)
{	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || soap_put_long(soap, p, "long", NULL) || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}
SOAP_FMAC3 long * SOAP_FMAC4 soap_get_long(struct soap*, long *, const char*, const char*);

inline int soap_read_long(struct soap *soap, long *p)
{	if (p)
	{	if (soap_begin_recv(soap) || soap_get_long(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_unsignedInt_DEFINED
#define SOAP_TYPE_unsignedInt_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedInt(struct soap*, unsigned int *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedInt(struct soap*, const char*, int, const unsigned int *, const char*);
SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_in_unsignedInt(struct soap*, const char*, unsigned int *, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedInt(struct soap*, const unsigned int *, const char*, const char*);

inline int soap_write_unsignedInt(struct soap *soap, unsigned int const *p)
{	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || soap_put_unsignedInt(soap, p, "unsignedInt", NULL) || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}
SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_get_unsignedInt(struct soap*, unsigned int *, const char*, const char*);

inline int soap_read_unsignedInt(struct soap *soap, unsigned int *p)
{	if (p)
	{	if (soap_begin_recv(soap) || soap_get_unsignedInt(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_unsignedLong_DEFINED
#define SOAP_TYPE_unsignedLong_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedLong(struct soap*, unsigned long *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedLong(struct soap*, const char*, int, const unsigned long *, const char*);
SOAP_FMAC3 unsigned long * SOAP_FMAC4 soap_in_unsignedLong(struct soap*, const char*, unsigned long *, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedLong(struct soap*, const unsigned long *, const char*, const char*);

inline int soap_write_unsignedLong(struct soap *soap, unsigned long const *p)
{	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || soap_put_unsignedLong(soap, p, "unsignedLong", NULL) || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}
SOAP_FMAC3 unsigned long * SOAP_FMAC4 soap_get_unsignedLong(struct soap*, unsigned long *, const char*, const char*);

inline int soap_read_unsignedLong(struct soap *soap, unsigned long *p)
{	if (p)
	{	if (soap_begin_recv(soap) || soap_get_unsignedLong(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_nsCXF__getDataCxfResponse_DEFINED
#define SOAP_TYPE_nsCXF__getDataCxfResponse_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_nsCXF__getDataCxfResponse(struct soap*, const char*, int, const nsCXF__getDataCxfResponse *, const char*);
SOAP_FMAC3 nsCXF__getDataCxfResponse * SOAP_FMAC4 soap_in_nsCXF__getDataCxfResponse(struct soap*, const char*, nsCXF__getDataCxfResponse *, const char*);
SOAP_FMAC1 nsCXF__getDataCxfResponse * SOAP_FMAC2 soap_instantiate_nsCXF__getDataCxfResponse(struct soap*, int, const char*, const char*, size_t*);

inline nsCXF__getDataCxfResponse * soap_new_nsCXF__getDataCxfResponse(struct soap *soap, int n = -1)
{	return soap_instantiate_nsCXF__getDataCxfResponse(soap, n, NULL, NULL, NULL);
}

inline nsCXF__getDataCxfResponse * soap_new_req_nsCXF__getDataCxfResponse(
	struct soap *soap)
{	nsCXF__getDataCxfResponse *_p = soap_new_nsCXF__getDataCxfResponse(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline nsCXF__getDataCxfResponse * soap_new_set_nsCXF__getDataCxfResponse(
	struct soap *soap,
	std::string *return_)
{	nsCXF__getDataCxfResponse *_p = soap_new_nsCXF__getDataCxfResponse(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->nsCXF__getDataCxfResponse::return_ = return_;
	}
	return _p;
}

inline int soap_write_nsCXF__getDataCxfResponse(struct soap *soap, nsCXF__getDataCxfResponse const *p)
{	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "nsCXF:getDataCxfResponse", NULL) || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}
SOAP_FMAC3 nsCXF__getDataCxfResponse * SOAP_FMAC4 soap_get_nsCXF__getDataCxfResponse(struct soap*, nsCXF__getDataCxfResponse *, const char*, const char*);

inline int soap_read_nsCXF__getDataCxfResponse(struct soap *soap, nsCXF__getDataCxfResponse *p)
{	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || soap_get_nsCXF__getDataCxfResponse(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_nsCXF__getDataCxf_DEFINED
#define SOAP_TYPE_nsCXF__getDataCxf_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_nsCXF__getDataCxf(struct soap*, const char*, int, const nsCXF__getDataCxf *, const char*);
SOAP_FMAC3 nsCXF__getDataCxf * SOAP_FMAC4 soap_in_nsCXF__getDataCxf(struct soap*, const char*, nsCXF__getDataCxf *, const char*);
SOAP_FMAC1 nsCXF__getDataCxf * SOAP_FMAC2 soap_instantiate_nsCXF__getDataCxf(struct soap*, int, const char*, const char*, size_t*);

inline nsCXF__getDataCxf * soap_new_nsCXF__getDataCxf(struct soap *soap, int n = -1)
{	return soap_instantiate_nsCXF__getDataCxf(soap, n, NULL, NULL, NULL);
}

inline nsCXF__getDataCxf * soap_new_req_nsCXF__getDataCxf(
	struct soap *soap)
{	nsCXF__getDataCxf *_p = soap_new_nsCXF__getDataCxf(soap);
	if (_p)
	{	_p->soap_default(soap);
	}
	return _p;
}

inline nsCXF__getDataCxf * soap_new_set_nsCXF__getDataCxf(
	struct soap *soap,
	std::string *arg0,
	std::string *arg1,
	std::string *arg2)
{	nsCXF__getDataCxf *_p = soap_new_nsCXF__getDataCxf(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->nsCXF__getDataCxf::arg0 = arg0;
		_p->nsCXF__getDataCxf::arg1 = arg1;
		_p->nsCXF__getDataCxf::arg2 = arg2;
	}
	return _p;
}

inline int soap_write_nsCXF__getDataCxf(struct soap *soap, nsCXF__getDataCxf const *p)
{	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "nsCXF:getDataCxf", NULL) || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}
SOAP_FMAC3 nsCXF__getDataCxf * SOAP_FMAC4 soap_get_nsCXF__getDataCxf(struct soap*, nsCXF__getDataCxf *, const char*, const char*);

inline int soap_read_nsCXF__getDataCxf(struct soap *soap, nsCXF__getDataCxf *p)
{	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || soap_get_nsCXF__getDataCxf(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE__ns1__getDataResponse_DEFINED
#define SOAP_TYPE__ns1__getDataResponse_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getDataResponse(struct soap*, const char*, int, const _ns1__getDataResponse *, const char*);
SOAP_FMAC3 _ns1__getDataResponse * SOAP_FMAC4 soap_in__ns1__getDataResponse(struct soap*, const char*, _ns1__getDataResponse *, const char*);
SOAP_FMAC1 _ns1__getDataResponse * SOAP_FMAC2 soap_instantiate__ns1__getDataResponse(struct soap*, int, const char*, const char*, size_t*);

inline _ns1__getDataResponse * soap_new__ns1__getDataResponse(struct soap *soap, int n = -1)
{	return soap_instantiate__ns1__getDataResponse(soap, n, NULL, NULL, NULL);
}

inline _ns1__getDataResponse * soap_new_req__ns1__getDataResponse(
	struct soap *soap,
	std::string *out)
{	_ns1__getDataResponse *_p = soap_new__ns1__getDataResponse(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->_ns1__getDataResponse::out = out;
	}
	return _p;
}

inline _ns1__getDataResponse * soap_new_set__ns1__getDataResponse(
	struct soap *soap,
	std::string *out)
{	_ns1__getDataResponse *_p = soap_new__ns1__getDataResponse(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->_ns1__getDataResponse::out = out;
	}
	return _p;
}

inline int soap_write__ns1__getDataResponse(struct soap *soap, _ns1__getDataResponse const *p)
{	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "ns1:getDataResponse", NULL) || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}
SOAP_FMAC3 _ns1__getDataResponse * SOAP_FMAC4 soap_get__ns1__getDataResponse(struct soap*, _ns1__getDataResponse *, const char*, const char*);

inline int soap_read__ns1__getDataResponse(struct soap *soap, _ns1__getDataResponse *p)
{	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || soap_get__ns1__getDataResponse(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE__ns1__getData_DEFINED
#define SOAP_TYPE__ns1__getData_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__getData(struct soap*, const char*, int, const _ns1__getData *, const char*);
SOAP_FMAC3 _ns1__getData * SOAP_FMAC4 soap_in__ns1__getData(struct soap*, const char*, _ns1__getData *, const char*);
SOAP_FMAC1 _ns1__getData * SOAP_FMAC2 soap_instantiate__ns1__getData(struct soap*, int, const char*, const char*, size_t*);

inline _ns1__getData * soap_new__ns1__getData(struct soap *soap, int n = -1)
{	return soap_instantiate__ns1__getData(soap, n, NULL, NULL, NULL);
}

inline _ns1__getData * soap_new_req__ns1__getData(
	struct soap *soap,
	std::string *in0,
	std::string *in1,
	std::string *in2)
{	_ns1__getData *_p = soap_new__ns1__getData(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->_ns1__getData::in0 = in0;
		_p->_ns1__getData::in1 = in1;
		_p->_ns1__getData::in2 = in2;
	}
	return _p;
}

inline _ns1__getData * soap_new_set__ns1__getData(
	struct soap *soap,
	std::string *in0,
	std::string *in1,
	std::string *in2)
{	_ns1__getData *_p = soap_new__ns1__getData(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->_ns1__getData::in0 = in0;
		_p->_ns1__getData::in1 = in1;
		_p->_ns1__getData::in2 = in2;
	}
	return _p;
}

inline int soap_write__ns1__getData(struct soap *soap, _ns1__getData const *p)
{	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "ns1:getData", NULL) || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}
SOAP_FMAC3 _ns1__getData * SOAP_FMAC4 soap_get__ns1__getData(struct soap*, _ns1__getData *, const char*, const char*);

inline int soap_read__ns1__getData(struct soap *soap, _ns1__getData *p)
{	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || soap_get__ns1__getData(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_std__string_DEFINED
#define SOAP_TYPE_std__string_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__string(struct soap*, std::string *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__string(struct soap*, const std::string *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__string(struct soap*, const char*, int, const std::string*, const char*);
SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_std__string(struct soap*, const char*, std::string*, const char*);
SOAP_FMAC1 std::string * SOAP_FMAC2 soap_instantiate_std__string(struct soap*, int, const char*, const char*, size_t*);

inline std::string * soap_new_std__string(struct soap *soap, int n = -1)
{	return soap_instantiate_std__string(soap, n, NULL, NULL, NULL);
}

inline std::string * soap_new_req_std__string(
	struct soap *soap)
{	std::string *_p = soap_new_std__string(soap);
	if (_p)
	{	soap_default_std__string(soap, _p);
	}
	return _p;
}

inline std::string * soap_new_set_std__string(
	struct soap *soap)
{	std::string *_p = soap_new_std__string(soap);
	if (_p)
	{	soap_default_std__string(soap, _p);
	}
	return _p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__string(struct soap*, const std::string *, const char*, const char*);

inline int soap_write_std__string(struct soap *soap, std::string const *p)
{	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || soap_put_std__string(soap, p, "string", NULL) || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}
SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_std__string(struct soap*, std::string *, const char*, const char*);

inline int soap_read_std__string(struct soap *soap, std::string *p)
{	if (p)
	{	if (soap_begin_recv(soap) || soap_get_std__string(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}
#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Fault_DEFINED
#define SOAP_TYPE_SOAP_ENV__Fault_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap*, struct SOAP_ENV__Fault *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap*, const struct SOAP_ENV__Fault *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap*, const char*, int, const struct SOAP_ENV__Fault *, const char*);
SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap*, const char*, struct SOAP_ENV__Fault *, const char*);
SOAP_FMAC1 struct SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap*, int, const char*, const char*, size_t*);

inline struct SOAP_ENV__Fault * soap_new_SOAP_ENV__Fault(struct soap *soap, int n = -1)
{	return soap_instantiate_SOAP_ENV__Fault(soap, n, NULL, NULL, NULL);
}

inline struct SOAP_ENV__Fault * soap_new_req_SOAP_ENV__Fault(
	struct soap *soap)
{	struct SOAP_ENV__Fault *_p = soap_new_SOAP_ENV__Fault(soap);
	if (_p)
	{	soap_default_SOAP_ENV__Fault(soap, _p);
	}
	return _p;
}

inline struct SOAP_ENV__Fault * soap_new_set_SOAP_ENV__Fault(
	struct soap *soap,
	char *faultcode,
	char *faultstring,
	char *faultactor,
	struct SOAP_ENV__Detail *detail,
	struct SOAP_ENV__Code *SOAP_ENV__Code,
	struct SOAP_ENV__Reason *SOAP_ENV__Reason,
	char *SOAP_ENV__Node,
	char *SOAP_ENV__Role,
	struct SOAP_ENV__Detail *SOAP_ENV__Detail)
{	struct SOAP_ENV__Fault *_p = soap_new_SOAP_ENV__Fault(soap);
	if (_p)
	{	soap_default_SOAP_ENV__Fault(soap, _p);
		_p->faultcode = faultcode;
		_p->faultstring = faultstring;
		_p->faultactor = faultactor;
		_p->detail = detail;
		_p->SOAP_ENV__Code = SOAP_ENV__Code;
		_p->SOAP_ENV__Reason = SOAP_ENV__Reason;
		_p->SOAP_ENV__Node = SOAP_ENV__Node;
		_p->SOAP_ENV__Role = SOAP_ENV__Role;
		_p->SOAP_ENV__Detail = SOAP_ENV__Detail;
	}
	return _p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap*, const struct SOAP_ENV__Fault *, const char*, const char*);

inline int soap_write_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault const *p)
{	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || (soap_serialize_SOAP_ENV__Fault(soap, p), 0) || soap_put_SOAP_ENV__Fault(soap, p, "SOAP-ENV:Fault", NULL) || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}
SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap*, struct SOAP_ENV__Fault *, const char*, const char*);

inline int soap_read_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p)
{	if (p)
	{	soap_default_SOAP_ENV__Fault(soap, p);
		if (soap_begin_recv(soap) || soap_get_SOAP_ENV__Fault(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Reason_DEFINED
#define SOAP_TYPE_SOAP_ENV__Reason_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap*, struct SOAP_ENV__Reason *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap*, const struct SOAP_ENV__Reason *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap*, const char*, int, const struct SOAP_ENV__Reason *, const char*);
SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap*, const char*, struct SOAP_ENV__Reason *, const char*);
SOAP_FMAC1 struct SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap*, int, const char*, const char*, size_t*);

inline struct SOAP_ENV__Reason * soap_new_SOAP_ENV__Reason(struct soap *soap, int n = -1)
{	return soap_instantiate_SOAP_ENV__Reason(soap, n, NULL, NULL, NULL);
}

inline struct SOAP_ENV__Reason * soap_new_req_SOAP_ENV__Reason(
	struct soap *soap)
{	struct SOAP_ENV__Reason *_p = soap_new_SOAP_ENV__Reason(soap);
	if (_p)
	{	soap_default_SOAP_ENV__Reason(soap, _p);
	}
	return _p;
}

inline struct SOAP_ENV__Reason * soap_new_set_SOAP_ENV__Reason(
	struct soap *soap,
	char *SOAP_ENV__Text)
{	struct SOAP_ENV__Reason *_p = soap_new_SOAP_ENV__Reason(soap);
	if (_p)
	{	soap_default_SOAP_ENV__Reason(soap, _p);
		_p->SOAP_ENV__Text = SOAP_ENV__Text;
	}
	return _p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap*, const struct SOAP_ENV__Reason *, const char*, const char*);

inline int soap_write_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason const *p)
{	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || (soap_serialize_SOAP_ENV__Reason(soap, p), 0) || soap_put_SOAP_ENV__Reason(soap, p, "SOAP-ENV:Reason", NULL) || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}
SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap*, struct SOAP_ENV__Reason *, const char*, const char*);

inline int soap_read_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p)
{	if (p)
	{	soap_default_SOAP_ENV__Reason(soap, p);
		if (soap_begin_recv(soap) || soap_get_SOAP_ENV__Reason(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Detail_DEFINED
#define SOAP_TYPE_SOAP_ENV__Detail_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap*, struct SOAP_ENV__Detail *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap*, const struct SOAP_ENV__Detail *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap*, const char*, int, const struct SOAP_ENV__Detail *, const char*);
SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap*, const char*, struct SOAP_ENV__Detail *, const char*);
SOAP_FMAC1 struct SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap*, int, const char*, const char*, size_t*);

inline struct SOAP_ENV__Detail * soap_new_SOAP_ENV__Detail(struct soap *soap, int n = -1)
{	return soap_instantiate_SOAP_ENV__Detail(soap, n, NULL, NULL, NULL);
}

inline struct SOAP_ENV__Detail * soap_new_req_SOAP_ENV__Detail(
	struct soap *soap,
	int __type,
	void *fault)
{	struct SOAP_ENV__Detail *_p = soap_new_SOAP_ENV__Detail(soap);
	if (_p)
	{	soap_default_SOAP_ENV__Detail(soap, _p);
		_p->__type = __type;
		_p->fault = fault;
	}
	return _p;
}

inline struct SOAP_ENV__Detail * soap_new_set_SOAP_ENV__Detail(
	struct soap *soap,
	char *__any,
	int __type,
	void *fault)
{	struct SOAP_ENV__Detail *_p = soap_new_SOAP_ENV__Detail(soap);
	if (_p)
	{	soap_default_SOAP_ENV__Detail(soap, _p);
		_p->__any = __any;
		_p->__type = __type;
		_p->fault = fault;
	}
	return _p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap*, const struct SOAP_ENV__Detail *, const char*, const char*);

inline int soap_write_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail const *p)
{	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || (soap_serialize_SOAP_ENV__Detail(soap, p), 0) || soap_put_SOAP_ENV__Detail(soap, p, "SOAP-ENV:Detail", NULL) || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}
SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap*, struct SOAP_ENV__Detail *, const char*, const char*);

inline int soap_read_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p)
{	if (p)
	{	soap_default_SOAP_ENV__Detail(soap, p);
		if (soap_begin_recv(soap) || soap_get_SOAP_ENV__Detail(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Code_DEFINED
#define SOAP_TYPE_SOAP_ENV__Code_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap*, struct SOAP_ENV__Code *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap*, const struct SOAP_ENV__Code *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap*, const char*, int, const struct SOAP_ENV__Code *, const char*);
SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap*, const char*, struct SOAP_ENV__Code *, const char*);
SOAP_FMAC1 struct SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap*, int, const char*, const char*, size_t*);

inline struct SOAP_ENV__Code * soap_new_SOAP_ENV__Code(struct soap *soap, int n = -1)
{	return soap_instantiate_SOAP_ENV__Code(soap, n, NULL, NULL, NULL);
}

inline struct SOAP_ENV__Code * soap_new_req_SOAP_ENV__Code(
	struct soap *soap)
{	struct SOAP_ENV__Code *_p = soap_new_SOAP_ENV__Code(soap);
	if (_p)
	{	soap_default_SOAP_ENV__Code(soap, _p);
	}
	return _p;
}

inline struct SOAP_ENV__Code * soap_new_set_SOAP_ENV__Code(
	struct soap *soap,
	char *SOAP_ENV__Value,
	struct SOAP_ENV__Code *SOAP_ENV__Subcode)
{	struct SOAP_ENV__Code *_p = soap_new_SOAP_ENV__Code(soap);
	if (_p)
	{	soap_default_SOAP_ENV__Code(soap, _p);
		_p->SOAP_ENV__Value = SOAP_ENV__Value;
		_p->SOAP_ENV__Subcode = SOAP_ENV__Subcode;
	}
	return _p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap*, const struct SOAP_ENV__Code *, const char*, const char*);

inline int soap_write_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code const *p)
{	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || (soap_serialize_SOAP_ENV__Code(soap, p), 0) || soap_put_SOAP_ENV__Code(soap, p, "SOAP-ENV:Code", NULL) || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}
SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap*, struct SOAP_ENV__Code *, const char*, const char*);

inline int soap_read_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p)
{	if (p)
	{	soap_default_SOAP_ENV__Code(soap, p);
		if (soap_begin_recv(soap) || soap_get_SOAP_ENV__Code(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Header_DEFINED
#define SOAP_TYPE_SOAP_ENV__Header_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap*, struct SOAP_ENV__Header *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap*, const struct SOAP_ENV__Header *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap*, const char*, int, const struct SOAP_ENV__Header *, const char*);
SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap*, const char*, struct SOAP_ENV__Header *, const char*);
SOAP_FMAC1 struct SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap*, int, const char*, const char*, size_t*);

inline struct SOAP_ENV__Header * soap_new_SOAP_ENV__Header(struct soap *soap, int n = -1)
{	return soap_instantiate_SOAP_ENV__Header(soap, n, NULL, NULL, NULL);
}

inline struct SOAP_ENV__Header * soap_new_req_SOAP_ENV__Header(
	struct soap *soap)
{	struct SOAP_ENV__Header *_p = soap_new_SOAP_ENV__Header(soap);
	if (_p)
	{	soap_default_SOAP_ENV__Header(soap, _p);
	}
	return _p;
}

inline struct SOAP_ENV__Header * soap_new_set_SOAP_ENV__Header(
	struct soap *soap)
{	struct SOAP_ENV__Header *_p = soap_new_SOAP_ENV__Header(soap);
	if (_p)
	{	soap_default_SOAP_ENV__Header(soap, _p);
	}
	return _p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap*, const struct SOAP_ENV__Header *, const char*, const char*);

inline int soap_write_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header const *p)
{	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || (soap_serialize_SOAP_ENV__Header(soap, p), 0) || soap_put_SOAP_ENV__Header(soap, p, "SOAP-ENV:Header", NULL) || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}
SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap*, struct SOAP_ENV__Header *, const char*, const char*);

inline int soap_read_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p)
{	if (p)
	{	soap_default_SOAP_ENV__Header(soap, p);
		if (soap_begin_recv(soap) || soap_get_SOAP_ENV__Header(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}
#endif

#endif

#ifndef SOAP_TYPE___nsCXF__getDataCxf_DEFINED
#define SOAP_TYPE___nsCXF__getDataCxf_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default___nsCXF__getDataCxf(struct soap*, struct __nsCXF__getDataCxf *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___nsCXF__getDataCxf(struct soap*, const struct __nsCXF__getDataCxf *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out___nsCXF__getDataCxf(struct soap*, const char*, int, const struct __nsCXF__getDataCxf *, const char*);
SOAP_FMAC3 struct __nsCXF__getDataCxf * SOAP_FMAC4 soap_in___nsCXF__getDataCxf(struct soap*, const char*, struct __nsCXF__getDataCxf *, const char*);
SOAP_FMAC1 struct __nsCXF__getDataCxf * SOAP_FMAC2 soap_instantiate___nsCXF__getDataCxf(struct soap*, int, const char*, const char*, size_t*);

inline struct __nsCXF__getDataCxf * soap_new___nsCXF__getDataCxf(struct soap *soap, int n = -1)
{	return soap_instantiate___nsCXF__getDataCxf(soap, n, NULL, NULL, NULL);
}

inline struct __nsCXF__getDataCxf * soap_new_req___nsCXF__getDataCxf(
	struct soap *soap)
{	struct __nsCXF__getDataCxf *_p = soap_new___nsCXF__getDataCxf(soap);
	if (_p)
	{	soap_default___nsCXF__getDataCxf(soap, _p);
	}
	return _p;
}

inline struct __nsCXF__getDataCxf * soap_new_set___nsCXF__getDataCxf(
	struct soap *soap,
	nsCXF__getDataCxf *nsCXF__getDataCxf_)
{	struct __nsCXF__getDataCxf *_p = soap_new___nsCXF__getDataCxf(soap);
	if (_p)
	{	soap_default___nsCXF__getDataCxf(soap, _p);
		_p->nsCXF__getDataCxf_ = nsCXF__getDataCxf_;
	}
	return _p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_put___nsCXF__getDataCxf(struct soap*, const struct __nsCXF__getDataCxf *, const char*, const char*);

inline int soap_write___nsCXF__getDataCxf(struct soap *soap, struct __nsCXF__getDataCxf const *p)
{	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || (soap_serialize___nsCXF__getDataCxf(soap, p), 0) || soap_put___nsCXF__getDataCxf(soap, p, "-nsCXF:getDataCxf", NULL) || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}
SOAP_FMAC3 struct __nsCXF__getDataCxf * SOAP_FMAC4 soap_get___nsCXF__getDataCxf(struct soap*, struct __nsCXF__getDataCxf *, const char*, const char*);

inline int soap_read___nsCXF__getDataCxf(struct soap *soap, struct __nsCXF__getDataCxf *p)
{	if (p)
	{	soap_default___nsCXF__getDataCxf(soap, p);
		if (soap_begin_recv(soap) || soap_get___nsCXF__getDataCxf(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE___ns1__getData_DEFINED
#define SOAP_TYPE___ns1__getData_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getData(struct soap*, struct __ns1__getData *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getData(struct soap*, const struct __ns1__getData *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getData(struct soap*, const char*, int, const struct __ns1__getData *, const char*);
SOAP_FMAC3 struct __ns1__getData * SOAP_FMAC4 soap_in___ns1__getData(struct soap*, const char*, struct __ns1__getData *, const char*);
SOAP_FMAC1 struct __ns1__getData * SOAP_FMAC2 soap_instantiate___ns1__getData(struct soap*, int, const char*, const char*, size_t*);

inline struct __ns1__getData * soap_new___ns1__getData(struct soap *soap, int n = -1)
{	return soap_instantiate___ns1__getData(soap, n, NULL, NULL, NULL);
}

inline struct __ns1__getData * soap_new_req___ns1__getData(
	struct soap *soap)
{	struct __ns1__getData *_p = soap_new___ns1__getData(soap);
	if (_p)
	{	soap_default___ns1__getData(soap, _p);
	}
	return _p;
}

inline struct __ns1__getData * soap_new_set___ns1__getData(
	struct soap *soap,
	_ns1__getData *ns1__getData)
{	struct __ns1__getData *_p = soap_new___ns1__getData(soap);
	if (_p)
	{	soap_default___ns1__getData(soap, _p);
		_p->ns1__getData = ns1__getData;
	}
	return _p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getData(struct soap*, const struct __ns1__getData *, const char*, const char*);

inline int soap_write___ns1__getData(struct soap *soap, struct __ns1__getData const *p)
{	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || (soap_serialize___ns1__getData(soap, p), 0) || soap_put___ns1__getData(soap, p, "-ns1:getData", NULL) || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}
SOAP_FMAC3 struct __ns1__getData * SOAP_FMAC4 soap_get___ns1__getData(struct soap*, struct __ns1__getData *, const char*, const char*);

inline int soap_read___ns1__getData(struct soap *soap, struct __ns1__getData *p)
{	if (p)
	{	soap_default___ns1__getData(soap, p);
		if (soap_begin_recv(soap) || soap_get___ns1__getData(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_ns__HBOperate_DEFINED
#define SOAP_TYPE_ns__HBOperate_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__HBOperate(struct soap*, struct ns__HBOperate *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__HBOperate(struct soap*, const struct ns__HBOperate *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__HBOperate(struct soap*, const char*, int, const struct ns__HBOperate *, const char*);
SOAP_FMAC3 struct ns__HBOperate * SOAP_FMAC4 soap_in_ns__HBOperate(struct soap*, const char*, struct ns__HBOperate *, const char*);
SOAP_FMAC1 struct ns__HBOperate * SOAP_FMAC2 soap_instantiate_ns__HBOperate(struct soap*, int, const char*, const char*, size_t*);

inline struct ns__HBOperate * soap_new_ns__HBOperate(struct soap *soap, int n = -1)
{	return soap_instantiate_ns__HBOperate(soap, n, NULL, NULL, NULL);
}

inline struct ns__HBOperate * soap_new_req_ns__HBOperate(
	struct soap *soap)
{	struct ns__HBOperate *_p = soap_new_ns__HBOperate(soap);
	if (_p)
	{	soap_default_ns__HBOperate(soap, _p);
	}
	return _p;
}

inline struct ns__HBOperate * soap_new_set_ns__HBOperate(
	struct soap *soap,
	char *szXml)
{	struct ns__HBOperate *_p = soap_new_ns__HBOperate(soap);
	if (_p)
	{	soap_default_ns__HBOperate(soap, _p);
		_p->szXml = szXml;
	}
	return _p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__HBOperate(struct soap*, const struct ns__HBOperate *, const char*, const char*);

inline int soap_write_ns__HBOperate(struct soap *soap, struct ns__HBOperate const *p)
{	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || (soap_serialize_ns__HBOperate(soap, p), 0) || soap_put_ns__HBOperate(soap, p, "ns:HBOperate", NULL) || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}
SOAP_FMAC3 struct ns__HBOperate * SOAP_FMAC4 soap_get_ns__HBOperate(struct soap*, struct ns__HBOperate *, const char*, const char*);

inline int soap_read_ns__HBOperate(struct soap *soap, struct ns__HBOperate *p)
{	if (p)
	{	soap_default_ns__HBOperate(soap, p);
		if (soap_begin_recv(soap) || soap_get_ns__HBOperate(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_ns__HBOperateResponse_DEFINED
#define SOAP_TYPE_ns__HBOperateResponse_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__HBOperateResponse(struct soap*, struct ns__HBOperateResponse *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__HBOperateResponse(struct soap*, const struct ns__HBOperateResponse *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__HBOperateResponse(struct soap*, const char*, int, const struct ns__HBOperateResponse *, const char*);
SOAP_FMAC3 struct ns__HBOperateResponse * SOAP_FMAC4 soap_in_ns__HBOperateResponse(struct soap*, const char*, struct ns__HBOperateResponse *, const char*);
SOAP_FMAC1 struct ns__HBOperateResponse * SOAP_FMAC2 soap_instantiate_ns__HBOperateResponse(struct soap*, int, const char*, const char*, size_t*);

inline struct ns__HBOperateResponse * soap_new_ns__HBOperateResponse(struct soap *soap, int n = -1)
{	return soap_instantiate_ns__HBOperateResponse(soap, n, NULL, NULL, NULL);
}

inline struct ns__HBOperateResponse * soap_new_req_ns__HBOperateResponse(
	struct soap *soap,
	char *szXmlRes)
{	struct ns__HBOperateResponse *_p = soap_new_ns__HBOperateResponse(soap);
	if (_p)
	{	soap_default_ns__HBOperateResponse(soap, _p);
		_p->szXmlRes = szXmlRes;
	}
	return _p;
}

inline struct ns__HBOperateResponse * soap_new_set_ns__HBOperateResponse(
	struct soap *soap,
	char *szXmlRes)
{	struct ns__HBOperateResponse *_p = soap_new_ns__HBOperateResponse(soap);
	if (_p)
	{	soap_default_ns__HBOperateResponse(soap, _p);
		_p->szXmlRes = szXmlRes;
	}
	return _p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__HBOperateResponse(struct soap*, const struct ns__HBOperateResponse *, const char*, const char*);

inline int soap_write_ns__HBOperateResponse(struct soap *soap, struct ns__HBOperateResponse const *p)
{	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || (soap_serialize_ns__HBOperateResponse(soap, p), 0) || soap_put_ns__HBOperateResponse(soap, p, "ns:HBOperateResponse", NULL) || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}
SOAP_FMAC3 struct ns__HBOperateResponse * SOAP_FMAC4 soap_get_ns__HBOperateResponse(struct soap*, struct ns__HBOperateResponse *, const char*, const char*);

inline int soap_read_ns__HBOperateResponse(struct soap *soap, struct ns__HBOperateResponse *p)
{	if (p)
	{	soap_default_ns__HBOperateResponse(soap, p);
		if (soap_begin_recv(soap) || soap_get_ns__HBOperateResponse(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_ns__NetMaster_DEFINED
#define SOAP_TYPE_ns__NetMaster_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__NetMaster(struct soap*, struct ns__NetMaster *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__NetMaster(struct soap*, const struct ns__NetMaster *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__NetMaster(struct soap*, const char*, int, const struct ns__NetMaster *, const char*);
SOAP_FMAC3 struct ns__NetMaster * SOAP_FMAC4 soap_in_ns__NetMaster(struct soap*, const char*, struct ns__NetMaster *, const char*);
SOAP_FMAC1 struct ns__NetMaster * SOAP_FMAC2 soap_instantiate_ns__NetMaster(struct soap*, int, const char*, const char*, size_t*);

inline struct ns__NetMaster * soap_new_ns__NetMaster(struct soap *soap, int n = -1)
{	return soap_instantiate_ns__NetMaster(soap, n, NULL, NULL, NULL);
}

inline struct ns__NetMaster * soap_new_req_ns__NetMaster(
	struct soap *soap,
	int nIsOK)
{	struct ns__NetMaster *_p = soap_new_ns__NetMaster(soap);
	if (_p)
	{	soap_default_ns__NetMaster(soap, _p);
		_p->nIsOK = nIsOK;
	}
	return _p;
}

inline struct ns__NetMaster * soap_new_set_ns__NetMaster(
	struct soap *soap,
	int nIsOK)
{	struct ns__NetMaster *_p = soap_new_ns__NetMaster(soap);
	if (_p)
	{	soap_default_ns__NetMaster(soap, _p);
		_p->nIsOK = nIsOK;
	}
	return _p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__NetMaster(struct soap*, const struct ns__NetMaster *, const char*, const char*);

inline int soap_write_ns__NetMaster(struct soap *soap, struct ns__NetMaster const *p)
{	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || (soap_serialize_ns__NetMaster(soap, p), 0) || soap_put_ns__NetMaster(soap, p, "ns:NetMaster", NULL) || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}
SOAP_FMAC3 struct ns__NetMaster * SOAP_FMAC4 soap_get_ns__NetMaster(struct soap*, struct ns__NetMaster *, const char*, const char*);

inline int soap_read_ns__NetMaster(struct soap *soap, struct ns__NetMaster *p)
{	if (p)
	{	soap_default_ns__NetMaster(soap, p);
		if (soap_begin_recv(soap) || soap_get_ns__NetMaster(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_ns__NetMasterResponse_DEFINED
#define SOAP_TYPE_ns__NetMasterResponse_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__NetMasterResponse(struct soap*, struct ns__NetMasterResponse *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__NetMasterResponse(struct soap*, const struct ns__NetMasterResponse *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__NetMasterResponse(struct soap*, const char*, int, const struct ns__NetMasterResponse *, const char*);
SOAP_FMAC3 struct ns__NetMasterResponse * SOAP_FMAC4 soap_in_ns__NetMasterResponse(struct soap*, const char*, struct ns__NetMasterResponse *, const char*);
SOAP_FMAC1 struct ns__NetMasterResponse * SOAP_FMAC2 soap_instantiate_ns__NetMasterResponse(struct soap*, int, const char*, const char*, size_t*);

inline struct ns__NetMasterResponse * soap_new_ns__NetMasterResponse(struct soap *soap, int n = -1)
{	return soap_instantiate_ns__NetMasterResponse(soap, n, NULL, NULL, NULL);
}

inline struct ns__NetMasterResponse * soap_new_req_ns__NetMasterResponse(
	struct soap *soap,
	int nResult)
{	struct ns__NetMasterResponse *_p = soap_new_ns__NetMasterResponse(soap);
	if (_p)
	{	soap_default_ns__NetMasterResponse(soap, _p);
		_p->nResult = nResult;
	}
	return _p;
}

inline struct ns__NetMasterResponse * soap_new_set_ns__NetMasterResponse(
	struct soap *soap,
	int nResult)
{	struct ns__NetMasterResponse *_p = soap_new_ns__NetMasterResponse(soap);
	if (_p)
	{	soap_default_ns__NetMasterResponse(soap, _p);
		_p->nResult = nResult;
	}
	return _p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__NetMasterResponse(struct soap*, const struct ns__NetMasterResponse *, const char*, const char*);

inline int soap_write_ns__NetMasterResponse(struct soap *soap, struct ns__NetMasterResponse const *p)
{	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || (soap_serialize_ns__NetMasterResponse(soap, p), 0) || soap_put_ns__NetMasterResponse(soap, p, "ns:NetMasterResponse", NULL) || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}
SOAP_FMAC3 struct ns__NetMasterResponse * SOAP_FMAC4 soap_get_ns__NetMasterResponse(struct soap*, struct ns__NetMasterResponse *, const char*, const char*);

inline int soap_read_ns__NetMasterResponse(struct soap *soap, struct ns__NetMasterResponse *p)
{	if (p)
	{	soap_default_ns__NetMasterResponse(soap, p);
		if (soap_begin_recv(soap) || soap_get_ns__NetMasterResponse(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_ns__AutoSysUpdate_DEFINED
#define SOAP_TYPE_ns__AutoSysUpdate_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__AutoSysUpdate(struct soap*, struct ns__AutoSysUpdate *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__AutoSysUpdate(struct soap*, const struct ns__AutoSysUpdate *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__AutoSysUpdate(struct soap*, const char*, int, const struct ns__AutoSysUpdate *, const char*);
SOAP_FMAC3 struct ns__AutoSysUpdate * SOAP_FMAC4 soap_in_ns__AutoSysUpdate(struct soap*, const char*, struct ns__AutoSysUpdate *, const char*);
SOAP_FMAC1 struct ns__AutoSysUpdate * SOAP_FMAC2 soap_instantiate_ns__AutoSysUpdate(struct soap*, int, const char*, const char*, size_t*);

inline struct ns__AutoSysUpdate * soap_new_ns__AutoSysUpdate(struct soap *soap, int n = -1)
{	return soap_instantiate_ns__AutoSysUpdate(soap, n, NULL, NULL, NULL);
}

inline struct ns__AutoSysUpdate * soap_new_req_ns__AutoSysUpdate(
	struct soap *soap,
	const std::string& strXmlFile)
{	struct ns__AutoSysUpdate *_p = soap_new_ns__AutoSysUpdate(soap);
	if (_p)
	{	soap_default_ns__AutoSysUpdate(soap, _p);
		_p->strXmlFile = strXmlFile;
	}
	return _p;
}

inline struct ns__AutoSysUpdate * soap_new_set_ns__AutoSysUpdate(
	struct soap *soap,
	const std::string& strXmlFile)
{	struct ns__AutoSysUpdate *_p = soap_new_ns__AutoSysUpdate(soap);
	if (_p)
	{	soap_default_ns__AutoSysUpdate(soap, _p);
		_p->strXmlFile = strXmlFile;
	}
	return _p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__AutoSysUpdate(struct soap*, const struct ns__AutoSysUpdate *, const char*, const char*);

inline int soap_write_ns__AutoSysUpdate(struct soap *soap, struct ns__AutoSysUpdate const *p)
{	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || (soap_serialize_ns__AutoSysUpdate(soap, p), 0) || soap_put_ns__AutoSysUpdate(soap, p, "ns:AutoSysUpdate", NULL) || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}
SOAP_FMAC3 struct ns__AutoSysUpdate * SOAP_FMAC4 soap_get_ns__AutoSysUpdate(struct soap*, struct ns__AutoSysUpdate *, const char*, const char*);

inline int soap_read_ns__AutoSysUpdate(struct soap *soap, struct ns__AutoSysUpdate *p)
{	if (p)
	{	soap_default_ns__AutoSysUpdate(soap, p);
		if (soap_begin_recv(soap) || soap_get_ns__AutoSysUpdate(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_ns__HeartBeat_DEFINED
#define SOAP_TYPE_ns__HeartBeat_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__HeartBeat(struct soap*, struct ns__HeartBeat *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__HeartBeat(struct soap*, const struct ns__HeartBeat *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__HeartBeat(struct soap*, const char*, int, const struct ns__HeartBeat *, const char*);
SOAP_FMAC3 struct ns__HeartBeat * SOAP_FMAC4 soap_in_ns__HeartBeat(struct soap*, const char*, struct ns__HeartBeat *, const char*);
SOAP_FMAC1 struct ns__HeartBeat * SOAP_FMAC2 soap_instantiate_ns__HeartBeat(struct soap*, int, const char*, const char*, size_t*);

inline struct ns__HeartBeat * soap_new_ns__HeartBeat(struct soap *soap, int n = -1)
{	return soap_instantiate_ns__HeartBeat(soap, n, NULL, NULL, NULL);
}

inline struct ns__HeartBeat * soap_new_req_ns__HeartBeat(
	struct soap *soap,
	const struct ns_HeartBeat& nsHeartBeat)
{	struct ns__HeartBeat *_p = soap_new_ns__HeartBeat(soap);
	if (_p)
	{	soap_default_ns__HeartBeat(soap, _p);
		_p->nsHeartBeat = nsHeartBeat;
	}
	return _p;
}

inline struct ns__HeartBeat * soap_new_set_ns__HeartBeat(
	struct soap *soap,
	const struct ns_HeartBeat& nsHeartBeat)
{	struct ns__HeartBeat *_p = soap_new_ns__HeartBeat(soap);
	if (_p)
	{	soap_default_ns__HeartBeat(soap, _p);
		_p->nsHeartBeat = nsHeartBeat;
	}
	return _p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__HeartBeat(struct soap*, const struct ns__HeartBeat *, const char*, const char*);

inline int soap_write_ns__HeartBeat(struct soap *soap, struct ns__HeartBeat const *p)
{	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || (soap_serialize_ns__HeartBeat(soap, p), 0) || soap_put_ns__HeartBeat(soap, p, "ns:HeartBeat", NULL) || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}
SOAP_FMAC3 struct ns__HeartBeat * SOAP_FMAC4 soap_get_ns__HeartBeat(struct soap*, struct ns__HeartBeat *, const char*, const char*);

inline int soap_read_ns__HeartBeat(struct soap *soap, struct ns__HeartBeat *p)
{	if (p)
	{	soap_default_ns__HeartBeat(soap, p);
		if (soap_begin_recv(soap) || soap_get_ns__HeartBeat(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_ns__AbandonVideoRecord_DEFINED
#define SOAP_TYPE_ns__AbandonVideoRecord_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__AbandonVideoRecord(struct soap*, struct ns__AbandonVideoRecord *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__AbandonVideoRecord(struct soap*, const struct ns__AbandonVideoRecord *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__AbandonVideoRecord(struct soap*, const char*, int, const struct ns__AbandonVideoRecord *, const char*);
SOAP_FMAC3 struct ns__AbandonVideoRecord * SOAP_FMAC4 soap_in_ns__AbandonVideoRecord(struct soap*, const char*, struct ns__AbandonVideoRecord *, const char*);
SOAP_FMAC1 struct ns__AbandonVideoRecord * SOAP_FMAC2 soap_instantiate_ns__AbandonVideoRecord(struct soap*, int, const char*, const char*, size_t*);

inline struct ns__AbandonVideoRecord * soap_new_ns__AbandonVideoRecord(struct soap *soap, int n = -1)
{	return soap_instantiate_ns__AbandonVideoRecord(soap, n, NULL, NULL, NULL);
}

inline struct ns__AbandonVideoRecord * soap_new_req_ns__AbandonVideoRecord(
	struct soap *soap,
	const struct ns__HBUSERINFO& nsUserInfo,
	long CamID)
{	struct ns__AbandonVideoRecord *_p = soap_new_ns__AbandonVideoRecord(soap);
	if (_p)
	{	soap_default_ns__AbandonVideoRecord(soap, _p);
		_p->nsUserInfo = nsUserInfo;
		_p->CamID = CamID;
	}
	return _p;
}

inline struct ns__AbandonVideoRecord * soap_new_set_ns__AbandonVideoRecord(
	struct soap *soap,
	const struct ns__HBUSERINFO& nsUserInfo,
	long CamID,
	char *FileName)
{	struct ns__AbandonVideoRecord *_p = soap_new_ns__AbandonVideoRecord(soap);
	if (_p)
	{	soap_default_ns__AbandonVideoRecord(soap, _p);
		_p->nsUserInfo = nsUserInfo;
		_p->CamID = CamID;
		_p->FileName = FileName;
	}
	return _p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__AbandonVideoRecord(struct soap*, const struct ns__AbandonVideoRecord *, const char*, const char*);

inline int soap_write_ns__AbandonVideoRecord(struct soap *soap, struct ns__AbandonVideoRecord const *p)
{	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || (soap_serialize_ns__AbandonVideoRecord(soap, p), 0) || soap_put_ns__AbandonVideoRecord(soap, p, "ns:AbandonVideoRecord", NULL) || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}
SOAP_FMAC3 struct ns__AbandonVideoRecord * SOAP_FMAC4 soap_get_ns__AbandonVideoRecord(struct soap*, struct ns__AbandonVideoRecord *, const char*, const char*);

inline int soap_read_ns__AbandonVideoRecord(struct soap *soap, struct ns__AbandonVideoRecord *p)
{	if (p)
	{	soap_default_ns__AbandonVideoRecord(soap, p);
		if (soap_begin_recv(soap) || soap_get_ns__AbandonVideoRecord(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_ns__DownloadVideoRecord_DEFINED
#define SOAP_TYPE_ns__DownloadVideoRecord_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__DownloadVideoRecord(struct soap*, struct ns__DownloadVideoRecord *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__DownloadVideoRecord(struct soap*, const struct ns__DownloadVideoRecord *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__DownloadVideoRecord(struct soap*, const char*, int, const struct ns__DownloadVideoRecord *, const char*);
SOAP_FMAC3 struct ns__DownloadVideoRecord * SOAP_FMAC4 soap_in_ns__DownloadVideoRecord(struct soap*, const char*, struct ns__DownloadVideoRecord *, const char*);
SOAP_FMAC1 struct ns__DownloadVideoRecord * SOAP_FMAC2 soap_instantiate_ns__DownloadVideoRecord(struct soap*, int, const char*, const char*, size_t*);

inline struct ns__DownloadVideoRecord * soap_new_ns__DownloadVideoRecord(struct soap *soap, int n = -1)
{	return soap_instantiate_ns__DownloadVideoRecord(soap, n, NULL, NULL, NULL);
}

inline struct ns__DownloadVideoRecord * soap_new_req_ns__DownloadVideoRecord(
	struct soap *soap,
	const struct ns__HBUSERINFO& nsUserInfo,
	long CamID)
{	struct ns__DownloadVideoRecord *_p = soap_new_ns__DownloadVideoRecord(soap);
	if (_p)
	{	soap_default_ns__DownloadVideoRecord(soap, _p);
		_p->nsUserInfo = nsUserInfo;
		_p->CamID = CamID;
	}
	return _p;
}

inline struct ns__DownloadVideoRecord * soap_new_set_ns__DownloadVideoRecord(
	struct soap *soap,
	const struct ns__HBUSERINFO& nsUserInfo,
	long CamID,
	char *szFileName)
{	struct ns__DownloadVideoRecord *_p = soap_new_ns__DownloadVideoRecord(soap);
	if (_p)
	{	soap_default_ns__DownloadVideoRecord(soap, _p);
		_p->nsUserInfo = nsUserInfo;
		_p->CamID = CamID;
		_p->szFileName = szFileName;
	}
	return _p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__DownloadVideoRecord(struct soap*, const struct ns__DownloadVideoRecord *, const char*, const char*);

inline int soap_write_ns__DownloadVideoRecord(struct soap *soap, struct ns__DownloadVideoRecord const *p)
{	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || (soap_serialize_ns__DownloadVideoRecord(soap, p), 0) || soap_put_ns__DownloadVideoRecord(soap, p, "ns:DownloadVideoRecord", NULL) || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}
SOAP_FMAC3 struct ns__DownloadVideoRecord * SOAP_FMAC4 soap_get_ns__DownloadVideoRecord(struct soap*, struct ns__DownloadVideoRecord *, const char*, const char*);

inline int soap_read_ns__DownloadVideoRecord(struct soap *soap, struct ns__DownloadVideoRecord *p)
{	if (p)
	{	soap_default_ns__DownloadVideoRecord(soap, p);
		if (soap_begin_recv(soap) || soap_get_ns__DownloadVideoRecord(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_ns__DownloadVideoRecordResponse_DEFINED
#define SOAP_TYPE_ns__DownloadVideoRecordResponse_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__DownloadVideoRecordResponse(struct soap*, struct ns__DownloadVideoRecordResponse *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__DownloadVideoRecordResponse(struct soap*, const struct ns__DownloadVideoRecordResponse *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__DownloadVideoRecordResponse(struct soap*, const char*, int, const struct ns__DownloadVideoRecordResponse *, const char*);
SOAP_FMAC3 struct ns__DownloadVideoRecordResponse * SOAP_FMAC4 soap_in_ns__DownloadVideoRecordResponse(struct soap*, const char*, struct ns__DownloadVideoRecordResponse *, const char*);
SOAP_FMAC1 struct ns__DownloadVideoRecordResponse * SOAP_FMAC2 soap_instantiate_ns__DownloadVideoRecordResponse(struct soap*, int, const char*, const char*, size_t*);

inline struct ns__DownloadVideoRecordResponse * soap_new_ns__DownloadVideoRecordResponse(struct soap *soap, int n = -1)
{	return soap_instantiate_ns__DownloadVideoRecordResponse(soap, n, NULL, NULL, NULL);
}

inline struct ns__DownloadVideoRecordResponse * soap_new_req_ns__DownloadVideoRecordResponse(
	struct soap *soap,
	char *OutFileName)
{	struct ns__DownloadVideoRecordResponse *_p = soap_new_ns__DownloadVideoRecordResponse(soap);
	if (_p)
	{	soap_default_ns__DownloadVideoRecordResponse(soap, _p);
		_p->OutFileName = OutFileName;
	}
	return _p;
}

inline struct ns__DownloadVideoRecordResponse * soap_new_set_ns__DownloadVideoRecordResponse(
	struct soap *soap,
	char *OutFileName)
{	struct ns__DownloadVideoRecordResponse *_p = soap_new_ns__DownloadVideoRecordResponse(soap);
	if (_p)
	{	soap_default_ns__DownloadVideoRecordResponse(soap, _p);
		_p->OutFileName = OutFileName;
	}
	return _p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__DownloadVideoRecordResponse(struct soap*, const struct ns__DownloadVideoRecordResponse *, const char*, const char*);

inline int soap_write_ns__DownloadVideoRecordResponse(struct soap *soap, struct ns__DownloadVideoRecordResponse const *p)
{	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || (soap_serialize_ns__DownloadVideoRecordResponse(soap, p), 0) || soap_put_ns__DownloadVideoRecordResponse(soap, p, "ns:DownloadVideoRecordResponse", NULL) || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}
SOAP_FMAC3 struct ns__DownloadVideoRecordResponse * SOAP_FMAC4 soap_get_ns__DownloadVideoRecordResponse(struct soap*, struct ns__DownloadVideoRecordResponse *, const char*, const char*);

inline int soap_read_ns__DownloadVideoRecordResponse(struct soap *soap, struct ns__DownloadVideoRecordResponse *p)
{	if (p)
	{	soap_default_ns__DownloadVideoRecordResponse(soap, p);
		if (soap_begin_recv(soap) || soap_get_ns__DownloadVideoRecordResponse(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_ns__PlayVideoRecord_DEFINED
#define SOAP_TYPE_ns__PlayVideoRecord_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__PlayVideoRecord(struct soap*, struct ns__PlayVideoRecord *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__PlayVideoRecord(struct soap*, const struct ns__PlayVideoRecord *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__PlayVideoRecord(struct soap*, const char*, int, const struct ns__PlayVideoRecord *, const char*);
SOAP_FMAC3 struct ns__PlayVideoRecord * SOAP_FMAC4 soap_in_ns__PlayVideoRecord(struct soap*, const char*, struct ns__PlayVideoRecord *, const char*);
SOAP_FMAC1 struct ns__PlayVideoRecord * SOAP_FMAC2 soap_instantiate_ns__PlayVideoRecord(struct soap*, int, const char*, const char*, size_t*);

inline struct ns__PlayVideoRecord * soap_new_ns__PlayVideoRecord(struct soap *soap, int n = -1)
{	return soap_instantiate_ns__PlayVideoRecord(soap, n, NULL, NULL, NULL);
}

inline struct ns__PlayVideoRecord * soap_new_req_ns__PlayVideoRecord(
	struct soap *soap,
	const struct ns__HBUSERINFO& nsUserInfo,
	long CamID)
{	struct ns__PlayVideoRecord *_p = soap_new_ns__PlayVideoRecord(soap);
	if (_p)
	{	soap_default_ns__PlayVideoRecord(soap, _p);
		_p->nsUserInfo = nsUserInfo;
		_p->CamID = CamID;
	}
	return _p;
}

inline struct ns__PlayVideoRecord * soap_new_set_ns__PlayVideoRecord(
	struct soap *soap,
	const struct ns__HBUSERINFO& nsUserInfo,
	long CamID,
	struct ns__HBNET_VIDEO_STREAM *Data)
{	struct ns__PlayVideoRecord *_p = soap_new_ns__PlayVideoRecord(soap);
	if (_p)
	{	soap_default_ns__PlayVideoRecord(soap, _p);
		_p->nsUserInfo = nsUserInfo;
		_p->CamID = CamID;
		_p->Data = Data;
	}
	return _p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__PlayVideoRecord(struct soap*, const struct ns__PlayVideoRecord *, const char*, const char*);

inline int soap_write_ns__PlayVideoRecord(struct soap *soap, struct ns__PlayVideoRecord const *p)
{	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || (soap_serialize_ns__PlayVideoRecord(soap, p), 0) || soap_put_ns__PlayVideoRecord(soap, p, "ns:PlayVideoRecord", NULL) || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}
SOAP_FMAC3 struct ns__PlayVideoRecord * SOAP_FMAC4 soap_get_ns__PlayVideoRecord(struct soap*, struct ns__PlayVideoRecord *, const char*, const char*);

inline int soap_read_ns__PlayVideoRecord(struct soap *soap, struct ns__PlayVideoRecord *p)
{	if (p)
	{	soap_default_ns__PlayVideoRecord(soap, p);
		if (soap_begin_recv(soap) || soap_get_ns__PlayVideoRecord(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_ns__QueryVideoRecord_DEFINED
#define SOAP_TYPE_ns__QueryVideoRecord_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__QueryVideoRecord(struct soap*, struct ns__QueryVideoRecord *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__QueryVideoRecord(struct soap*, const struct ns__QueryVideoRecord *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__QueryVideoRecord(struct soap*, const char*, int, const struct ns__QueryVideoRecord *, const char*);
SOAP_FMAC3 struct ns__QueryVideoRecord * SOAP_FMAC4 soap_in_ns__QueryVideoRecord(struct soap*, const char*, struct ns__QueryVideoRecord *, const char*);
SOAP_FMAC1 struct ns__QueryVideoRecord * SOAP_FMAC2 soap_instantiate_ns__QueryVideoRecord(struct soap*, int, const char*, const char*, size_t*);

inline struct ns__QueryVideoRecord * soap_new_ns__QueryVideoRecord(struct soap *soap, int n = -1)
{	return soap_instantiate_ns__QueryVideoRecord(soap, n, NULL, NULL, NULL);
}

inline struct ns__QueryVideoRecord * soap_new_req_ns__QueryVideoRecord(
	struct soap *soap,
	const struct ns__HBUSERINFO& nsUserInfo,
	long CamID)
{	struct ns__QueryVideoRecord *_p = soap_new_ns__QueryVideoRecord(soap);
	if (_p)
	{	soap_default_ns__QueryVideoRecord(soap, _p);
		_p->nsUserInfo = nsUserInfo;
		_p->CamID = CamID;
	}
	return _p;
}

inline struct ns__QueryVideoRecord * soap_new_set_ns__QueryVideoRecord(
	struct soap *soap,
	const struct ns__HBUSERINFO& nsUserInfo,
	long CamID,
	struct ns__HBNET_RECOED_FILECOND *Param)
{	struct ns__QueryVideoRecord *_p = soap_new_ns__QueryVideoRecord(soap);
	if (_p)
	{	soap_default_ns__QueryVideoRecord(soap, _p);
		_p->nsUserInfo = nsUserInfo;
		_p->CamID = CamID;
		_p->Param = Param;
	}
	return _p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__QueryVideoRecord(struct soap*, const struct ns__QueryVideoRecord *, const char*, const char*);

inline int soap_write_ns__QueryVideoRecord(struct soap *soap, struct ns__QueryVideoRecord const *p)
{	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || (soap_serialize_ns__QueryVideoRecord(soap, p), 0) || soap_put_ns__QueryVideoRecord(soap, p, "ns:QueryVideoRecord", NULL) || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}
SOAP_FMAC3 struct ns__QueryVideoRecord * SOAP_FMAC4 soap_get_ns__QueryVideoRecord(struct soap*, struct ns__QueryVideoRecord *, const char*, const char*);

inline int soap_read_ns__QueryVideoRecord(struct soap *soap, struct ns__QueryVideoRecord *p)
{	if (p)
	{	soap_default_ns__QueryVideoRecord(soap, p);
		if (soap_begin_recv(soap) || soap_get_ns__QueryVideoRecord(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_ns__QueryVideoRecordResponse_DEFINED
#define SOAP_TYPE_ns__QueryVideoRecordResponse_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__QueryVideoRecordResponse(struct soap*, struct ns__QueryVideoRecordResponse *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__QueryVideoRecordResponse(struct soap*, const struct ns__QueryVideoRecordResponse *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__QueryVideoRecordResponse(struct soap*, const char*, int, const struct ns__QueryVideoRecordResponse *, const char*);
SOAP_FMAC3 struct ns__QueryVideoRecordResponse * SOAP_FMAC4 soap_in_ns__QueryVideoRecordResponse(struct soap*, const char*, struct ns__QueryVideoRecordResponse *, const char*);
SOAP_FMAC1 struct ns__QueryVideoRecordResponse * SOAP_FMAC2 soap_instantiate_ns__QueryVideoRecordResponse(struct soap*, int, const char*, const char*, size_t*);

inline struct ns__QueryVideoRecordResponse * soap_new_ns__QueryVideoRecordResponse(struct soap *soap, int n = -1)
{	return soap_instantiate_ns__QueryVideoRecordResponse(soap, n, NULL, NULL, NULL);
}

inline struct ns__QueryVideoRecordResponse * soap_new_req_ns__QueryVideoRecordResponse(
	struct soap *soap,
	char *RecodeList)
{	struct ns__QueryVideoRecordResponse *_p = soap_new_ns__QueryVideoRecordResponse(soap);
	if (_p)
	{	soap_default_ns__QueryVideoRecordResponse(soap, _p);
		_p->RecodeList = RecodeList;
	}
	return _p;
}

inline struct ns__QueryVideoRecordResponse * soap_new_set_ns__QueryVideoRecordResponse(
	struct soap *soap,
	char *RecodeList)
{	struct ns__QueryVideoRecordResponse *_p = soap_new_ns__QueryVideoRecordResponse(soap);
	if (_p)
	{	soap_default_ns__QueryVideoRecordResponse(soap, _p);
		_p->RecodeList = RecodeList;
	}
	return _p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__QueryVideoRecordResponse(struct soap*, const struct ns__QueryVideoRecordResponse *, const char*, const char*);

inline int soap_write_ns__QueryVideoRecordResponse(struct soap *soap, struct ns__QueryVideoRecordResponse const *p)
{	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || (soap_serialize_ns__QueryVideoRecordResponse(soap, p), 0) || soap_put_ns__QueryVideoRecordResponse(soap, p, "ns:QueryVideoRecordResponse", NULL) || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}
SOAP_FMAC3 struct ns__QueryVideoRecordResponse * SOAP_FMAC4 soap_get_ns__QueryVideoRecordResponse(struct soap*, struct ns__QueryVideoRecordResponse *, const char*, const char*);

inline int soap_read_ns__QueryVideoRecordResponse(struct soap *soap, struct ns__QueryVideoRecordResponse *p)
{	if (p)
	{	soap_default_ns__QueryVideoRecordResponse(soap, p);
		if (soap_begin_recv(soap) || soap_get_ns__QueryVideoRecordResponse(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_ns__AbandonCameraStream_DEFINED
#define SOAP_TYPE_ns__AbandonCameraStream_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__AbandonCameraStream(struct soap*, struct ns__AbandonCameraStream *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__AbandonCameraStream(struct soap*, const struct ns__AbandonCameraStream *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__AbandonCameraStream(struct soap*, const char*, int, const struct ns__AbandonCameraStream *, const char*);
SOAP_FMAC3 struct ns__AbandonCameraStream * SOAP_FMAC4 soap_in_ns__AbandonCameraStream(struct soap*, const char*, struct ns__AbandonCameraStream *, const char*);
SOAP_FMAC1 struct ns__AbandonCameraStream * SOAP_FMAC2 soap_instantiate_ns__AbandonCameraStream(struct soap*, int, const char*, const char*, size_t*);

inline struct ns__AbandonCameraStream * soap_new_ns__AbandonCameraStream(struct soap *soap, int n = -1)
{	return soap_instantiate_ns__AbandonCameraStream(soap, n, NULL, NULL, NULL);
}

inline struct ns__AbandonCameraStream * soap_new_req_ns__AbandonCameraStream(
	struct soap *soap,
	const struct ns__HBUSERINFO& nsUserInfo,
	long CamID)
{	struct ns__AbandonCameraStream *_p = soap_new_ns__AbandonCameraStream(soap);
	if (_p)
	{	soap_default_ns__AbandonCameraStream(soap, _p);
		_p->nsUserInfo = nsUserInfo;
		_p->CamID = CamID;
	}
	return _p;
}

inline struct ns__AbandonCameraStream * soap_new_set_ns__AbandonCameraStream(
	struct soap *soap,
	const struct ns__HBUSERINFO& nsUserInfo,
	long CamID)
{	struct ns__AbandonCameraStream *_p = soap_new_ns__AbandonCameraStream(soap);
	if (_p)
	{	soap_default_ns__AbandonCameraStream(soap, _p);
		_p->nsUserInfo = nsUserInfo;
		_p->CamID = CamID;
	}
	return _p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__AbandonCameraStream(struct soap*, const struct ns__AbandonCameraStream *, const char*, const char*);

inline int soap_write_ns__AbandonCameraStream(struct soap *soap, struct ns__AbandonCameraStream const *p)
{	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || (soap_serialize_ns__AbandonCameraStream(soap, p), 0) || soap_put_ns__AbandonCameraStream(soap, p, "ns:AbandonCameraStream", NULL) || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}
SOAP_FMAC3 struct ns__AbandonCameraStream * SOAP_FMAC4 soap_get_ns__AbandonCameraStream(struct soap*, struct ns__AbandonCameraStream *, const char*, const char*);

inline int soap_read_ns__AbandonCameraStream(struct soap *soap, struct ns__AbandonCameraStream *p)
{	if (p)
	{	soap_default_ns__AbandonCameraStream(soap, p);
		if (soap_begin_recv(soap) || soap_get_ns__AbandonCameraStream(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_ns__PTZCtrlCamera_DEFINED
#define SOAP_TYPE_ns__PTZCtrlCamera_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__PTZCtrlCamera(struct soap*, struct ns__PTZCtrlCamera *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__PTZCtrlCamera(struct soap*, const struct ns__PTZCtrlCamera *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__PTZCtrlCamera(struct soap*, const char*, int, const struct ns__PTZCtrlCamera *, const char*);
SOAP_FMAC3 struct ns__PTZCtrlCamera * SOAP_FMAC4 soap_in_ns__PTZCtrlCamera(struct soap*, const char*, struct ns__PTZCtrlCamera *, const char*);
SOAP_FMAC1 struct ns__PTZCtrlCamera * SOAP_FMAC2 soap_instantiate_ns__PTZCtrlCamera(struct soap*, int, const char*, const char*, size_t*);

inline struct ns__PTZCtrlCamera * soap_new_ns__PTZCtrlCamera(struct soap *soap, int n = -1)
{	return soap_instantiate_ns__PTZCtrlCamera(soap, n, NULL, NULL, NULL);
}

inline struct ns__PTZCtrlCamera * soap_new_req_ns__PTZCtrlCamera(
	struct soap *soap,
	const struct ns__HBUSERINFO& nsUserInfo,
	long CamID)
{	struct ns__PTZCtrlCamera *_p = soap_new_ns__PTZCtrlCamera(soap);
	if (_p)
	{	soap_default_ns__PTZCtrlCamera(soap, _p);
		_p->nsUserInfo = nsUserInfo;
		_p->CamID = CamID;
	}
	return _p;
}

inline struct ns__PTZCtrlCamera * soap_new_set_ns__PTZCtrlCamera(
	struct soap *soap,
	const struct ns__HBUSERINFO& nsUserInfo,
	long CamID,
	struct ns__HBNET_CAMERA_PTZCTRL *Data)
{	struct ns__PTZCtrlCamera *_p = soap_new_ns__PTZCtrlCamera(soap);
	if (_p)
	{	soap_default_ns__PTZCtrlCamera(soap, _p);
		_p->nsUserInfo = nsUserInfo;
		_p->CamID = CamID;
		_p->Data = Data;
	}
	return _p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__PTZCtrlCamera(struct soap*, const struct ns__PTZCtrlCamera *, const char*, const char*);

inline int soap_write_ns__PTZCtrlCamera(struct soap *soap, struct ns__PTZCtrlCamera const *p)
{	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || (soap_serialize_ns__PTZCtrlCamera(soap, p), 0) || soap_put_ns__PTZCtrlCamera(soap, p, "ns:PTZCtrlCamera", NULL) || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}
SOAP_FMAC3 struct ns__PTZCtrlCamera * SOAP_FMAC4 soap_get_ns__PTZCtrlCamera(struct soap*, struct ns__PTZCtrlCamera *, const char*, const char*);

inline int soap_read_ns__PTZCtrlCamera(struct soap *soap, struct ns__PTZCtrlCamera *p)
{	if (p)
	{	soap_default_ns__PTZCtrlCamera(soap, p);
		if (soap_begin_recv(soap) || soap_get_ns__PTZCtrlCamera(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_ns__SwitchCameraToStream_DEFINED
#define SOAP_TYPE_ns__SwitchCameraToStream_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__SwitchCameraToStream(struct soap*, struct ns__SwitchCameraToStream *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__SwitchCameraToStream(struct soap*, const struct ns__SwitchCameraToStream *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__SwitchCameraToStream(struct soap*, const char*, int, const struct ns__SwitchCameraToStream *, const char*);
SOAP_FMAC3 struct ns__SwitchCameraToStream * SOAP_FMAC4 soap_in_ns__SwitchCameraToStream(struct soap*, const char*, struct ns__SwitchCameraToStream *, const char*);
SOAP_FMAC1 struct ns__SwitchCameraToStream * SOAP_FMAC2 soap_instantiate_ns__SwitchCameraToStream(struct soap*, int, const char*, const char*, size_t*);

inline struct ns__SwitchCameraToStream * soap_new_ns__SwitchCameraToStream(struct soap *soap, int n = -1)
{	return soap_instantiate_ns__SwitchCameraToStream(soap, n, NULL, NULL, NULL);
}

inline struct ns__SwitchCameraToStream * soap_new_req_ns__SwitchCameraToStream(
	struct soap *soap,
	const struct ns__HBUSERINFO& nsUserInfo,
	long CamID)
{	struct ns__SwitchCameraToStream *_p = soap_new_ns__SwitchCameraToStream(soap);
	if (_p)
	{	soap_default_ns__SwitchCameraToStream(soap, _p);
		_p->nsUserInfo = nsUserInfo;
		_p->CamID = CamID;
	}
	return _p;
}

inline struct ns__SwitchCameraToStream * soap_new_set_ns__SwitchCameraToStream(
	struct soap *soap,
	const struct ns__HBUSERINFO& nsUserInfo,
	long CamID)
{	struct ns__SwitchCameraToStream *_p = soap_new_ns__SwitchCameraToStream(soap);
	if (_p)
	{	soap_default_ns__SwitchCameraToStream(soap, _p);
		_p->nsUserInfo = nsUserInfo;
		_p->CamID = CamID;
	}
	return _p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__SwitchCameraToStream(struct soap*, const struct ns__SwitchCameraToStream *, const char*, const char*);

inline int soap_write_ns__SwitchCameraToStream(struct soap *soap, struct ns__SwitchCameraToStream const *p)
{	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || (soap_serialize_ns__SwitchCameraToStream(soap, p), 0) || soap_put_ns__SwitchCameraToStream(soap, p, "ns:SwitchCameraToStream", NULL) || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}
SOAP_FMAC3 struct ns__SwitchCameraToStream * SOAP_FMAC4 soap_get_ns__SwitchCameraToStream(struct soap*, struct ns__SwitchCameraToStream *, const char*, const char*);

inline int soap_read_ns__SwitchCameraToStream(struct soap *soap, struct ns__SwitchCameraToStream *p)
{	if (p)
	{	soap_default_ns__SwitchCameraToStream(soap, p);
		if (soap_begin_recv(soap) || soap_get_ns__SwitchCameraToStream(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_ns_HeartBeat_DEFINED
#define SOAP_TYPE_ns_HeartBeat_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns_HeartBeat(struct soap*, struct ns_HeartBeat *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns_HeartBeat(struct soap*, const struct ns_HeartBeat *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns_HeartBeat(struct soap*, const char*, int, const struct ns_HeartBeat *, const char*);
SOAP_FMAC3 struct ns_HeartBeat * SOAP_FMAC4 soap_in_ns_HeartBeat(struct soap*, const char*, struct ns_HeartBeat *, const char*);
SOAP_FMAC1 struct ns_HeartBeat * SOAP_FMAC2 soap_instantiate_ns_HeartBeat(struct soap*, int, const char*, const char*, size_t*);

inline struct ns_HeartBeat * soap_new_ns_HeartBeat(struct soap *soap, int n = -1)
{	return soap_instantiate_ns_HeartBeat(soap, n, NULL, NULL, NULL);
}

inline struct ns_HeartBeat * soap_new_req_ns_HeartBeat(
	struct soap *soap,
	const std::string& strUser,
	unsigned long ulCameraID,
	int nPlayType,
	const std::string& strFileName)
{	struct ns_HeartBeat *_p = soap_new_ns_HeartBeat(soap);
	if (_p)
	{	soap_default_ns_HeartBeat(soap, _p);
		_p->strUser = strUser;
		_p->ulCameraID = ulCameraID;
		_p->nPlayType = nPlayType;
		_p->strFileName = strFileName;
	}
	return _p;
}

inline struct ns_HeartBeat * soap_new_set_ns_HeartBeat(
	struct soap *soap,
	const std::string& strUser,
	unsigned long ulCameraID,
	int nPlayType,
	const std::string& strFileName)
{	struct ns_HeartBeat *_p = soap_new_ns_HeartBeat(soap);
	if (_p)
	{	soap_default_ns_HeartBeat(soap, _p);
		_p->strUser = strUser;
		_p->ulCameraID = ulCameraID;
		_p->nPlayType = nPlayType;
		_p->strFileName = strFileName;
	}
	return _p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns_HeartBeat(struct soap*, const struct ns_HeartBeat *, const char*, const char*);

inline int soap_write_ns_HeartBeat(struct soap *soap, struct ns_HeartBeat const *p)
{	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || (soap_serialize_ns_HeartBeat(soap, p), 0) || soap_put_ns_HeartBeat(soap, p, "ns-HeartBeat", NULL) || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}
SOAP_FMAC3 struct ns_HeartBeat * SOAP_FMAC4 soap_get_ns_HeartBeat(struct soap*, struct ns_HeartBeat *, const char*, const char*);

inline int soap_read_ns_HeartBeat(struct soap *soap, struct ns_HeartBeat *p)
{	if (p)
	{	soap_default_ns_HeartBeat(soap, p);
		if (soap_begin_recv(soap) || soap_get_ns_HeartBeat(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_ns__HBUSERINFO_DEFINED
#define SOAP_TYPE_ns__HBUSERINFO_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__HBUSERINFO(struct soap*, struct ns__HBUSERINFO *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__HBUSERINFO(struct soap*, const struct ns__HBUSERINFO *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__HBUSERINFO(struct soap*, const char*, int, const struct ns__HBUSERINFO *, const char*);
SOAP_FMAC3 struct ns__HBUSERINFO * SOAP_FMAC4 soap_in_ns__HBUSERINFO(struct soap*, const char*, struct ns__HBUSERINFO *, const char*);
SOAP_FMAC1 struct ns__HBUSERINFO * SOAP_FMAC2 soap_instantiate_ns__HBUSERINFO(struct soap*, int, const char*, const char*, size_t*);

inline struct ns__HBUSERINFO * soap_new_ns__HBUSERINFO(struct soap *soap, int n = -1)
{	return soap_instantiate_ns__HBUSERINFO(soap, n, NULL, NULL, NULL);
}

inline struct ns__HBUSERINFO * soap_new_req_ns__HBUSERINFO(
	struct soap *soap,
	const std::string& strUser,
	int nPermission,
	int nCtrlTimeOut)
{	struct ns__HBUSERINFO *_p = soap_new_ns__HBUSERINFO(soap);
	if (_p)
	{	soap_default_ns__HBUSERINFO(soap, _p);
		_p->strUser = strUser;
		_p->nPermission = nPermission;
		_p->nCtrlTimeOut = nCtrlTimeOut;
	}
	return _p;
}

inline struct ns__HBUSERINFO * soap_new_set_ns__HBUSERINFO(
	struct soap *soap,
	const std::string& strUser,
	int nPermission,
	int nCtrlTimeOut)
{	struct ns__HBUSERINFO *_p = soap_new_ns__HBUSERINFO(soap);
	if (_p)
	{	soap_default_ns__HBUSERINFO(soap, _p);
		_p->strUser = strUser;
		_p->nPermission = nPermission;
		_p->nCtrlTimeOut = nCtrlTimeOut;
	}
	return _p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__HBUSERINFO(struct soap*, const struct ns__HBUSERINFO *, const char*, const char*);

inline int soap_write_ns__HBUSERINFO(struct soap *soap, struct ns__HBUSERINFO const *p)
{	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || (soap_serialize_ns__HBUSERINFO(soap, p), 0) || soap_put_ns__HBUSERINFO(soap, p, "ns:HBUSERINFO", NULL) || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}
SOAP_FMAC3 struct ns__HBUSERINFO * SOAP_FMAC4 soap_get_ns__HBUSERINFO(struct soap*, struct ns__HBUSERINFO *, const char*, const char*);

inline int soap_read_ns__HBUSERINFO(struct soap *soap, struct ns__HBUSERINFO *p)
{	if (p)
	{	soap_default_ns__HBUSERINFO(soap, p);
		if (soap_begin_recv(soap) || soap_get_ns__HBUSERINFO(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_ns__HBNET_CAMREA_INFO_DEFINED
#define SOAP_TYPE_ns__HBNET_CAMREA_INFO_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__HBNET_CAMREA_INFO(struct soap*, struct ns__HBNET_CAMREA_INFO *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__HBNET_CAMREA_INFO(struct soap*, const struct ns__HBNET_CAMREA_INFO *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__HBNET_CAMREA_INFO(struct soap*, const char*, int, const struct ns__HBNET_CAMREA_INFO *, const char*);
SOAP_FMAC3 struct ns__HBNET_CAMREA_INFO * SOAP_FMAC4 soap_in_ns__HBNET_CAMREA_INFO(struct soap*, const char*, struct ns__HBNET_CAMREA_INFO *, const char*);
SOAP_FMAC1 struct ns__HBNET_CAMREA_INFO * SOAP_FMAC2 soap_instantiate_ns__HBNET_CAMREA_INFO(struct soap*, int, const char*, const char*, size_t*);

inline struct ns__HBNET_CAMREA_INFO * soap_new_ns__HBNET_CAMREA_INFO(struct soap *soap, int n = -1)
{	return soap_instantiate_ns__HBNET_CAMREA_INFO(soap, n, NULL, NULL, NULL);
}

inline struct ns__HBNET_CAMREA_INFO * soap_new_req_ns__HBNET_CAMREA_INFO(
	struct soap *soap,
	unsigned long ulCamNumber,
	unsigned long ulCamID,
	unsigned long ulCamDepartmentID,
	const std::string& strCamName)
{	struct ns__HBNET_CAMREA_INFO *_p = soap_new_ns__HBNET_CAMREA_INFO(soap);
	if (_p)
	{	soap_default_ns__HBNET_CAMREA_INFO(soap, _p);
		_p->ulCamNumber = ulCamNumber;
		_p->ulCamID = ulCamID;
		_p->ulCamDepartmentID = ulCamDepartmentID;
		_p->strCamName = strCamName;
	}
	return _p;
}

inline struct ns__HBNET_CAMREA_INFO * soap_new_set_ns__HBNET_CAMREA_INFO(
	struct soap *soap,
	unsigned long ulCamNumber,
	unsigned long ulCamID,
	unsigned long ulCamDepartmentID,
	const std::string& strCamName)
{	struct ns__HBNET_CAMREA_INFO *_p = soap_new_ns__HBNET_CAMREA_INFO(soap);
	if (_p)
	{	soap_default_ns__HBNET_CAMREA_INFO(soap, _p);
		_p->ulCamNumber = ulCamNumber;
		_p->ulCamID = ulCamID;
		_p->ulCamDepartmentID = ulCamDepartmentID;
		_p->strCamName = strCamName;
	}
	return _p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__HBNET_CAMREA_INFO(struct soap*, const struct ns__HBNET_CAMREA_INFO *, const char*, const char*);

inline int soap_write_ns__HBNET_CAMREA_INFO(struct soap *soap, struct ns__HBNET_CAMREA_INFO const *p)
{	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || (soap_serialize_ns__HBNET_CAMREA_INFO(soap, p), 0) || soap_put_ns__HBNET_CAMREA_INFO(soap, p, "ns:HBNET-CAMREA-INFO", NULL) || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}
SOAP_FMAC3 struct ns__HBNET_CAMREA_INFO * SOAP_FMAC4 soap_get_ns__HBNET_CAMREA_INFO(struct soap*, struct ns__HBNET_CAMREA_INFO *, const char*, const char*);

inline int soap_read_ns__HBNET_CAMREA_INFO(struct soap *soap, struct ns__HBNET_CAMREA_INFO *p)
{	if (p)
	{	soap_default_ns__HBNET_CAMREA_INFO(soap, p);
		if (soap_begin_recv(soap) || soap_get_ns__HBNET_CAMREA_INFO(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_ns__HBNET_RECOED_FILECOND_DEFINED
#define SOAP_TYPE_ns__HBNET_RECOED_FILECOND_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__HBNET_RECOED_FILECOND(struct soap*, struct ns__HBNET_RECOED_FILECOND *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__HBNET_RECOED_FILECOND(struct soap*, const struct ns__HBNET_RECOED_FILECOND *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__HBNET_RECOED_FILECOND(struct soap*, const char*, int, const struct ns__HBNET_RECOED_FILECOND *, const char*);
SOAP_FMAC3 struct ns__HBNET_RECOED_FILECOND * SOAP_FMAC4 soap_in_ns__HBNET_RECOED_FILECOND(struct soap*, const char*, struct ns__HBNET_RECOED_FILECOND *, const char*);
SOAP_FMAC1 struct ns__HBNET_RECOED_FILECOND * SOAP_FMAC2 soap_instantiate_ns__HBNET_RECOED_FILECOND(struct soap*, int, const char*, const char*, size_t*);

inline struct ns__HBNET_RECOED_FILECOND * soap_new_ns__HBNET_RECOED_FILECOND(struct soap *soap, int n = -1)
{	return soap_instantiate_ns__HBNET_RECOED_FILECOND(soap, n, NULL, NULL, NULL);
}

inline struct ns__HBNET_RECOED_FILECOND * soap_new_req_ns__HBNET_RECOED_FILECOND(
	struct soap *soap,
	unsigned long ulCamNumber,
	unsigned long ulStartTime,
	unsigned long ulStopTime)
{	struct ns__HBNET_RECOED_FILECOND *_p = soap_new_ns__HBNET_RECOED_FILECOND(soap);
	if (_p)
	{	soap_default_ns__HBNET_RECOED_FILECOND(soap, _p);
		_p->ulCamNumber = ulCamNumber;
		_p->ulStartTime = ulStartTime;
		_p->ulStopTime = ulStopTime;
	}
	return _p;
}

inline struct ns__HBNET_RECOED_FILECOND * soap_new_set_ns__HBNET_RECOED_FILECOND(
	struct soap *soap,
	unsigned long ulCamNumber,
	unsigned long ulStartTime,
	unsigned long ulStopTime)
{	struct ns__HBNET_RECOED_FILECOND *_p = soap_new_ns__HBNET_RECOED_FILECOND(soap);
	if (_p)
	{	soap_default_ns__HBNET_RECOED_FILECOND(soap, _p);
		_p->ulCamNumber = ulCamNumber;
		_p->ulStartTime = ulStartTime;
		_p->ulStopTime = ulStopTime;
	}
	return _p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__HBNET_RECOED_FILECOND(struct soap*, const struct ns__HBNET_RECOED_FILECOND *, const char*, const char*);

inline int soap_write_ns__HBNET_RECOED_FILECOND(struct soap *soap, struct ns__HBNET_RECOED_FILECOND const *p)
{	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || (soap_serialize_ns__HBNET_RECOED_FILECOND(soap, p), 0) || soap_put_ns__HBNET_RECOED_FILECOND(soap, p, "ns:HBNET-RECOED-FILECOND", NULL) || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}
SOAP_FMAC3 struct ns__HBNET_RECOED_FILECOND * SOAP_FMAC4 soap_get_ns__HBNET_RECOED_FILECOND(struct soap*, struct ns__HBNET_RECOED_FILECOND *, const char*, const char*);

inline int soap_read_ns__HBNET_RECOED_FILECOND(struct soap *soap, struct ns__HBNET_RECOED_FILECOND *p)
{	if (p)
	{	soap_default_ns__HBNET_RECOED_FILECOND(soap, p);
		if (soap_begin_recv(soap) || soap_get_ns__HBNET_RECOED_FILECOND(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_ns__HBNET_RECOED_PLAYCTRL_DEFINED
#define SOAP_TYPE_ns__HBNET_RECOED_PLAYCTRL_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__HBNET_RECOED_PLAYCTRL(struct soap*, struct ns__HBNET_RECOED_PLAYCTRL *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__HBNET_RECOED_PLAYCTRL(struct soap*, const struct ns__HBNET_RECOED_PLAYCTRL *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__HBNET_RECOED_PLAYCTRL(struct soap*, const char*, int, const struct ns__HBNET_RECOED_PLAYCTRL *, const char*);
SOAP_FMAC3 struct ns__HBNET_RECOED_PLAYCTRL * SOAP_FMAC4 soap_in_ns__HBNET_RECOED_PLAYCTRL(struct soap*, const char*, struct ns__HBNET_RECOED_PLAYCTRL *, const char*);
SOAP_FMAC1 struct ns__HBNET_RECOED_PLAYCTRL * SOAP_FMAC2 soap_instantiate_ns__HBNET_RECOED_PLAYCTRL(struct soap*, int, const char*, const char*, size_t*);

inline struct ns__HBNET_RECOED_PLAYCTRL * soap_new_ns__HBNET_RECOED_PLAYCTRL(struct soap *soap, int n = -1)
{	return soap_instantiate_ns__HBNET_RECOED_PLAYCTRL(soap, n, NULL, NULL, NULL);
}

inline struct ns__HBNET_RECOED_PLAYCTRL * soap_new_req_ns__HBNET_RECOED_PLAYCTRL(
	struct soap *soap,
	unsigned long ulControlCode,
	unsigned long ulInValue)
{	struct ns__HBNET_RECOED_PLAYCTRL *_p = soap_new_ns__HBNET_RECOED_PLAYCTRL(soap);
	if (_p)
	{	soap_default_ns__HBNET_RECOED_PLAYCTRL(soap, _p);
		_p->ulControlCode = ulControlCode;
		_p->ulInValue = ulInValue;
	}
	return _p;
}

inline struct ns__HBNET_RECOED_PLAYCTRL * soap_new_set_ns__HBNET_RECOED_PLAYCTRL(
	struct soap *soap,
	unsigned long ulControlCode,
	unsigned long ulInValue)
{	struct ns__HBNET_RECOED_PLAYCTRL *_p = soap_new_ns__HBNET_RECOED_PLAYCTRL(soap);
	if (_p)
	{	soap_default_ns__HBNET_RECOED_PLAYCTRL(soap, _p);
		_p->ulControlCode = ulControlCode;
		_p->ulInValue = ulInValue;
	}
	return _p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__HBNET_RECOED_PLAYCTRL(struct soap*, const struct ns__HBNET_RECOED_PLAYCTRL *, const char*, const char*);

inline int soap_write_ns__HBNET_RECOED_PLAYCTRL(struct soap *soap, struct ns__HBNET_RECOED_PLAYCTRL const *p)
{	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || (soap_serialize_ns__HBNET_RECOED_PLAYCTRL(soap, p), 0) || soap_put_ns__HBNET_RECOED_PLAYCTRL(soap, p, "ns:HBNET-RECOED-PLAYCTRL", NULL) || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}
SOAP_FMAC3 struct ns__HBNET_RECOED_PLAYCTRL * SOAP_FMAC4 soap_get_ns__HBNET_RECOED_PLAYCTRL(struct soap*, struct ns__HBNET_RECOED_PLAYCTRL *, const char*, const char*);

inline int soap_read_ns__HBNET_RECOED_PLAYCTRL(struct soap *soap, struct ns__HBNET_RECOED_PLAYCTRL *p)
{	if (p)
	{	soap_default_ns__HBNET_RECOED_PLAYCTRL(soap, p);
		if (soap_begin_recv(soap) || soap_get_ns__HBNET_RECOED_PLAYCTRL(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_ns__HBNET_CAMERA_PTZCTRL_DEFINED
#define SOAP_TYPE_ns__HBNET_CAMERA_PTZCTRL_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__HBNET_CAMERA_PTZCTRL(struct soap*, struct ns__HBNET_CAMERA_PTZCTRL *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__HBNET_CAMERA_PTZCTRL(struct soap*, const struct ns__HBNET_CAMERA_PTZCTRL *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__HBNET_CAMERA_PTZCTRL(struct soap*, const char*, int, const struct ns__HBNET_CAMERA_PTZCTRL *, const char*);
SOAP_FMAC3 struct ns__HBNET_CAMERA_PTZCTRL * SOAP_FMAC4 soap_in_ns__HBNET_CAMERA_PTZCTRL(struct soap*, const char*, struct ns__HBNET_CAMERA_PTZCTRL *, const char*);
SOAP_FMAC1 struct ns__HBNET_CAMERA_PTZCTRL * SOAP_FMAC2 soap_instantiate_ns__HBNET_CAMERA_PTZCTRL(struct soap*, int, const char*, const char*, size_t*);

inline struct ns__HBNET_CAMERA_PTZCTRL * soap_new_ns__HBNET_CAMERA_PTZCTRL(struct soap *soap, int n = -1)
{	return soap_instantiate_ns__HBNET_CAMERA_PTZCTRL(soap, n, NULL, NULL, NULL);
}

inline struct ns__HBNET_CAMERA_PTZCTRL * soap_new_req_ns__HBNET_CAMERA_PTZCTRL(
	struct soap *soap,
	unsigned long ulCamNumber,
	unsigned long ulVS1,
	unsigned long ulVS2,
	unsigned long ulVS3,
	unsigned long ulVS4)
{	struct ns__HBNET_CAMERA_PTZCTRL *_p = soap_new_ns__HBNET_CAMERA_PTZCTRL(soap);
	if (_p)
	{	soap_default_ns__HBNET_CAMERA_PTZCTRL(soap, _p);
		_p->ulCamNumber = ulCamNumber;
		_p->ulVS1 = ulVS1;
		_p->ulVS2 = ulVS2;
		_p->ulVS3 = ulVS3;
		_p->ulVS4 = ulVS4;
	}
	return _p;
}

inline struct ns__HBNET_CAMERA_PTZCTRL * soap_new_set_ns__HBNET_CAMERA_PTZCTRL(
	struct soap *soap,
	unsigned long ulCamNumber,
	unsigned long ulVS1,
	unsigned long ulVS2,
	unsigned long ulVS3,
	unsigned long ulVS4)
{	struct ns__HBNET_CAMERA_PTZCTRL *_p = soap_new_ns__HBNET_CAMERA_PTZCTRL(soap);
	if (_p)
	{	soap_default_ns__HBNET_CAMERA_PTZCTRL(soap, _p);
		_p->ulCamNumber = ulCamNumber;
		_p->ulVS1 = ulVS1;
		_p->ulVS2 = ulVS2;
		_p->ulVS3 = ulVS3;
		_p->ulVS4 = ulVS4;
	}
	return _p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__HBNET_CAMERA_PTZCTRL(struct soap*, const struct ns__HBNET_CAMERA_PTZCTRL *, const char*, const char*);

inline int soap_write_ns__HBNET_CAMERA_PTZCTRL(struct soap *soap, struct ns__HBNET_CAMERA_PTZCTRL const *p)
{	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || (soap_serialize_ns__HBNET_CAMERA_PTZCTRL(soap, p), 0) || soap_put_ns__HBNET_CAMERA_PTZCTRL(soap, p, "ns:HBNET-CAMERA-PTZCTRL", NULL) || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}
SOAP_FMAC3 struct ns__HBNET_CAMERA_PTZCTRL * SOAP_FMAC4 soap_get_ns__HBNET_CAMERA_PTZCTRL(struct soap*, struct ns__HBNET_CAMERA_PTZCTRL *, const char*, const char*);

inline int soap_read_ns__HBNET_CAMERA_PTZCTRL(struct soap *soap, struct ns__HBNET_CAMERA_PTZCTRL *p)
{	if (p)
	{	soap_default_ns__HBNET_CAMERA_PTZCTRL(soap, p);
		if (soap_begin_recv(soap) || soap_get_ns__HBNET_CAMERA_PTZCTRL(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_ns__HBNET_VIDEO_STREAM_RESP_DEFINED
#define SOAP_TYPE_ns__HBNET_VIDEO_STREAM_RESP_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__HBNET_VIDEO_STREAM_RESP(struct soap*, struct ns__HBNET_VIDEO_STREAM_RESP *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__HBNET_VIDEO_STREAM_RESP(struct soap*, const struct ns__HBNET_VIDEO_STREAM_RESP *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__HBNET_VIDEO_STREAM_RESP(struct soap*, const char*, int, const struct ns__HBNET_VIDEO_STREAM_RESP *, const char*);
SOAP_FMAC3 struct ns__HBNET_VIDEO_STREAM_RESP * SOAP_FMAC4 soap_in_ns__HBNET_VIDEO_STREAM_RESP(struct soap*, const char*, struct ns__HBNET_VIDEO_STREAM_RESP *, const char*);
SOAP_FMAC1 struct ns__HBNET_VIDEO_STREAM_RESP * SOAP_FMAC2 soap_instantiate_ns__HBNET_VIDEO_STREAM_RESP(struct soap*, int, const char*, const char*, size_t*);

inline struct ns__HBNET_VIDEO_STREAM_RESP * soap_new_ns__HBNET_VIDEO_STREAM_RESP(struct soap *soap, int n = -1)
{	return soap_instantiate_ns__HBNET_VIDEO_STREAM_RESP(soap, n, NULL, NULL, NULL);
}

inline struct ns__HBNET_VIDEO_STREAM_RESP * soap_new_req_ns__HBNET_VIDEO_STREAM_RESP(
	struct soap *soap,
	int vsfStreamType)
{	struct ns__HBNET_VIDEO_STREAM_RESP *_p = soap_new_ns__HBNET_VIDEO_STREAM_RESP(soap);
	if (_p)
	{	soap_default_ns__HBNET_VIDEO_STREAM_RESP(soap, _p);
		_p->vsfStreamType = vsfStreamType;
	}
	return _p;
}

inline struct ns__HBNET_VIDEO_STREAM_RESP * soap_new_set_ns__HBNET_VIDEO_STREAM_RESP(
	struct soap *soap,
	int vsfStreamType,
	char *szDescription)
{	struct ns__HBNET_VIDEO_STREAM_RESP *_p = soap_new_ns__HBNET_VIDEO_STREAM_RESP(soap);
	if (_p)
	{	soap_default_ns__HBNET_VIDEO_STREAM_RESP(soap, _p);
		_p->vsfStreamType = vsfStreamType;
		_p->szDescription = szDescription;
	}
	return _p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__HBNET_VIDEO_STREAM_RESP(struct soap*, const struct ns__HBNET_VIDEO_STREAM_RESP *, const char*, const char*);

inline int soap_write_ns__HBNET_VIDEO_STREAM_RESP(struct soap *soap, struct ns__HBNET_VIDEO_STREAM_RESP const *p)
{	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || (soap_serialize_ns__HBNET_VIDEO_STREAM_RESP(soap, p), 0) || soap_put_ns__HBNET_VIDEO_STREAM_RESP(soap, p, "ns:HBNET-VIDEO-STREAM-RESP", NULL) || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}
SOAP_FMAC3 struct ns__HBNET_VIDEO_STREAM_RESP * SOAP_FMAC4 soap_get_ns__HBNET_VIDEO_STREAM_RESP(struct soap*, struct ns__HBNET_VIDEO_STREAM_RESP *, const char*, const char*);

inline int soap_read_ns__HBNET_VIDEO_STREAM_RESP(struct soap *soap, struct ns__HBNET_VIDEO_STREAM_RESP *p)
{	if (p)
	{	soap_default_ns__HBNET_VIDEO_STREAM_RESP(soap, p);
		if (soap_begin_recv(soap) || soap_get_ns__HBNET_VIDEO_STREAM_RESP(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_ns__HBNET_VIDEO_STREAM_DEFINED
#define SOAP_TYPE_ns__HBNET_VIDEO_STREAM_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__HBNET_VIDEO_STREAM(struct soap*, struct ns__HBNET_VIDEO_STREAM *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__HBNET_VIDEO_STREAM(struct soap*, const struct ns__HBNET_VIDEO_STREAM *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__HBNET_VIDEO_STREAM(struct soap*, const char*, int, const struct ns__HBNET_VIDEO_STREAM *, const char*);
SOAP_FMAC3 struct ns__HBNET_VIDEO_STREAM * SOAP_FMAC4 soap_in_ns__HBNET_VIDEO_STREAM(struct soap*, const char*, struct ns__HBNET_VIDEO_STREAM *, const char*);
SOAP_FMAC1 struct ns__HBNET_VIDEO_STREAM * SOAP_FMAC2 soap_instantiate_ns__HBNET_VIDEO_STREAM(struct soap*, int, const char*, const char*, size_t*);

inline struct ns__HBNET_VIDEO_STREAM * soap_new_ns__HBNET_VIDEO_STREAM(struct soap *soap, int n = -1)
{	return soap_instantiate_ns__HBNET_VIDEO_STREAM(soap, n, NULL, NULL, NULL);
}

inline struct ns__HBNET_VIDEO_STREAM * soap_new_req_ns__HBNET_VIDEO_STREAM(
	struct soap *soap,
	int vsfStreamType)
{	struct ns__HBNET_VIDEO_STREAM *_p = soap_new_ns__HBNET_VIDEO_STREAM(soap);
	if (_p)
	{	soap_default_ns__HBNET_VIDEO_STREAM(soap, _p);
		_p->vsfStreamType = vsfStreamType;
	}
	return _p;
}

inline struct ns__HBNET_VIDEO_STREAM * soap_new_set_ns__HBNET_VIDEO_STREAM(
	struct soap *soap,
	int vsfStreamType,
	char *szDescription)
{	struct ns__HBNET_VIDEO_STREAM *_p = soap_new_ns__HBNET_VIDEO_STREAM(soap);
	if (_p)
	{	soap_default_ns__HBNET_VIDEO_STREAM(soap, _p);
		_p->vsfStreamType = vsfStreamType;
		_p->szDescription = szDescription;
	}
	return _p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__HBNET_VIDEO_STREAM(struct soap*, const struct ns__HBNET_VIDEO_STREAM *, const char*, const char*);

inline int soap_write_ns__HBNET_VIDEO_STREAM(struct soap *soap, struct ns__HBNET_VIDEO_STREAM const *p)
{	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || (soap_serialize_ns__HBNET_VIDEO_STREAM(soap, p), 0) || soap_put_ns__HBNET_VIDEO_STREAM(soap, p, "ns:HBNET-VIDEO-STREAM", NULL) || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}
SOAP_FMAC3 struct ns__HBNET_VIDEO_STREAM * SOAP_FMAC4 soap_get_ns__HBNET_VIDEO_STREAM(struct soap*, struct ns__HBNET_VIDEO_STREAM *, const char*, const char*);

inline int soap_read_ns__HBNET_VIDEO_STREAM(struct soap *soap, struct ns__HBNET_VIDEO_STREAM *p)
{	if (p)
	{	soap_default_ns__HBNET_VIDEO_STREAM(soap, p);
		if (soap_begin_recv(soap) || soap_get_ns__HBNET_VIDEO_STREAM(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_ns__Response_DEFINED
#define SOAP_TYPE_ns__Response_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__Response(struct soap*, struct ns__Response *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__Response(struct soap*, const struct ns__Response *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__Response(struct soap*, const char*, int, const struct ns__Response *, const char*);
SOAP_FMAC3 struct ns__Response * SOAP_FMAC4 soap_in_ns__Response(struct soap*, const char*, struct ns__Response *, const char*);
SOAP_FMAC1 struct ns__Response * SOAP_FMAC2 soap_instantiate_ns__Response(struct soap*, int, const char*, const char*, size_t*);

inline struct ns__Response * soap_new_ns__Response(struct soap *soap, int n = -1)
{	return soap_instantiate_ns__Response(soap, n, NULL, NULL, NULL);
}

inline struct ns__Response * soap_new_req_ns__Response(
	struct soap *soap,
	int retcode,
	const std::string& strMessage)
{	struct ns__Response *_p = soap_new_ns__Response(soap);
	if (_p)
	{	soap_default_ns__Response(soap, _p);
		_p->retcode = retcode;
		_p->strMessage = strMessage;
	}
	return _p;
}

inline struct ns__Response * soap_new_set_ns__Response(
	struct soap *soap,
	int retcode,
	const std::string& strMessage)
{	struct ns__Response *_p = soap_new_ns__Response(soap);
	if (_p)
	{	soap_default_ns__Response(soap, _p);
		_p->retcode = retcode;
		_p->strMessage = strMessage;
	}
	return _p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__Response(struct soap*, const struct ns__Response *, const char*, const char*);

inline int soap_write_ns__Response(struct soap *soap, struct ns__Response const *p)
{	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || (soap_serialize_ns__Response(soap, p), 0) || soap_put_ns__Response(soap, p, "ns:Response", NULL) || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}
SOAP_FMAC3 struct ns__Response * SOAP_FMAC4 soap_get_ns__Response(struct soap*, struct ns__Response *, const char*, const char*);

inline int soap_read_ns__Response(struct soap *soap, struct ns__Response *p)
{	if (p)
	{	soap_default_ns__Response(soap, p);
		if (soap_begin_recv(soap) || soap_get_ns__Response(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}
#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_PointerToSOAP_ENV__Reason_DEFINED
#define SOAP_TYPE_PointerToSOAP_ENV__Reason_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap*, struct SOAP_ENV__Reason *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap*, const char *, int, struct SOAP_ENV__Reason *const*, const char *);
SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap*, const char*, struct SOAP_ENV__Reason **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap*, struct SOAP_ENV__Reason *const*, const char*, const char*);
SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap*, struct SOAP_ENV__Reason **, const char*, const char*);
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_PointerToSOAP_ENV__Detail_DEFINED
#define SOAP_TYPE_PointerToSOAP_ENV__Detail_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap*, struct SOAP_ENV__Detail *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap*, const char *, int, struct SOAP_ENV__Detail *const*, const char *);
SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap*, const char*, struct SOAP_ENV__Detail **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap*, struct SOAP_ENV__Detail *const*, const char*, const char*);
SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap*, struct SOAP_ENV__Detail **, const char*, const char*);
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_PointerToSOAP_ENV__Code_DEFINED
#define SOAP_TYPE_PointerToSOAP_ENV__Code_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap*, struct SOAP_ENV__Code *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap*, const char *, int, struct SOAP_ENV__Code *const*, const char *);
SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap*, const char*, struct SOAP_ENV__Code **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap*, struct SOAP_ENV__Code *const*, const char*, const char*);
SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap*, struct SOAP_ENV__Code **, const char*, const char*);
#endif

#endif

#ifndef SOAP_TYPE_PointerTonsCXF__getDataCxfResponse_DEFINED
#define SOAP_TYPE_PointerTonsCXF__getDataCxfResponse_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTonsCXF__getDataCxfResponse(struct soap*, nsCXF__getDataCxfResponse *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTonsCXF__getDataCxfResponse(struct soap*, const char *, int, nsCXF__getDataCxfResponse *const*, const char *);
SOAP_FMAC3 nsCXF__getDataCxfResponse ** SOAP_FMAC4 soap_in_PointerTonsCXF__getDataCxfResponse(struct soap*, const char*, nsCXF__getDataCxfResponse **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTonsCXF__getDataCxfResponse(struct soap*, nsCXF__getDataCxfResponse *const*, const char*, const char*);
SOAP_FMAC3 nsCXF__getDataCxfResponse ** SOAP_FMAC4 soap_get_PointerTonsCXF__getDataCxfResponse(struct soap*, nsCXF__getDataCxfResponse **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTonsCXF__getDataCxf_DEFINED
#define SOAP_TYPE_PointerTonsCXF__getDataCxf_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTonsCXF__getDataCxf(struct soap*, nsCXF__getDataCxf *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTonsCXF__getDataCxf(struct soap*, const char *, int, nsCXF__getDataCxf *const*, const char *);
SOAP_FMAC3 nsCXF__getDataCxf ** SOAP_FMAC4 soap_in_PointerTonsCXF__getDataCxf(struct soap*, const char*, nsCXF__getDataCxf **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTonsCXF__getDataCxf(struct soap*, nsCXF__getDataCxf *const*, const char*, const char*);
SOAP_FMAC3 nsCXF__getDataCxf ** SOAP_FMAC4 soap_get_PointerTonsCXF__getDataCxf(struct soap*, nsCXF__getDataCxf **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTo_ns1__getDataResponse_DEFINED
#define SOAP_TYPE_PointerTo_ns1__getDataResponse_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getDataResponse(struct soap*, _ns1__getDataResponse *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getDataResponse(struct soap*, const char *, int, _ns1__getDataResponse *const*, const char *);
SOAP_FMAC3 _ns1__getDataResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__getDataResponse(struct soap*, const char*, _ns1__getDataResponse **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getDataResponse(struct soap*, _ns1__getDataResponse *const*, const char*, const char*);
SOAP_FMAC3 _ns1__getDataResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__getDataResponse(struct soap*, _ns1__getDataResponse **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTo_ns1__getData_DEFINED
#define SOAP_TYPE_PointerTo_ns1__getData_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__getData(struct soap*, _ns1__getData *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__getData(struct soap*, const char *, int, _ns1__getData *const*, const char *);
SOAP_FMAC3 _ns1__getData ** SOAP_FMAC4 soap_in_PointerTo_ns1__getData(struct soap*, const char*, _ns1__getData **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__getData(struct soap*, _ns1__getData *const*, const char*, const char*);
SOAP_FMAC3 _ns1__getData ** SOAP_FMAC4 soap_get_PointerTo_ns1__getData(struct soap*, _ns1__getData **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTostd__string_DEFINED
#define SOAP_TYPE_PointerTostd__string_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__string(struct soap*, std::string *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__string(struct soap*, const char *, int, std::string *const*, const char *);
SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTostd__string(struct soap*, const char*, std::string **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__string(struct soap*, std::string *const*, const char*, const char*);
SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTostd__string(struct soap*, std::string **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTons__HBNET_VIDEO_STREAM_RESP_DEFINED
#define SOAP_TYPE_PointerTons__HBNET_VIDEO_STREAM_RESP_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons__HBNET_VIDEO_STREAM_RESP(struct soap*, struct ns__HBNET_VIDEO_STREAM_RESP *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons__HBNET_VIDEO_STREAM_RESP(struct soap*, const char *, int, struct ns__HBNET_VIDEO_STREAM_RESP *const*, const char *);
SOAP_FMAC3 struct ns__HBNET_VIDEO_STREAM_RESP ** SOAP_FMAC4 soap_in_PointerTons__HBNET_VIDEO_STREAM_RESP(struct soap*, const char*, struct ns__HBNET_VIDEO_STREAM_RESP **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons__HBNET_VIDEO_STREAM_RESP(struct soap*, struct ns__HBNET_VIDEO_STREAM_RESP *const*, const char*, const char*);
SOAP_FMAC3 struct ns__HBNET_VIDEO_STREAM_RESP ** SOAP_FMAC4 soap_get_PointerTons__HBNET_VIDEO_STREAM_RESP(struct soap*, struct ns__HBNET_VIDEO_STREAM_RESP **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTons__HBNET_RECOED_FILECOND_DEFINED
#define SOAP_TYPE_PointerTons__HBNET_RECOED_FILECOND_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons__HBNET_RECOED_FILECOND(struct soap*, struct ns__HBNET_RECOED_FILECOND *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons__HBNET_RECOED_FILECOND(struct soap*, const char *, int, struct ns__HBNET_RECOED_FILECOND *const*, const char *);
SOAP_FMAC3 struct ns__HBNET_RECOED_FILECOND ** SOAP_FMAC4 soap_in_PointerTons__HBNET_RECOED_FILECOND(struct soap*, const char*, struct ns__HBNET_RECOED_FILECOND **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons__HBNET_RECOED_FILECOND(struct soap*, struct ns__HBNET_RECOED_FILECOND *const*, const char*, const char*);
SOAP_FMAC3 struct ns__HBNET_RECOED_FILECOND ** SOAP_FMAC4 soap_get_PointerTons__HBNET_RECOED_FILECOND(struct soap*, struct ns__HBNET_RECOED_FILECOND **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTons__Response_DEFINED
#define SOAP_TYPE_PointerTons__Response_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons__Response(struct soap*, struct ns__Response *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons__Response(struct soap*, const char *, int, struct ns__Response *const*, const char *);
SOAP_FMAC3 struct ns__Response ** SOAP_FMAC4 soap_in_PointerTons__Response(struct soap*, const char*, struct ns__Response **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons__Response(struct soap*, struct ns__Response *const*, const char*, const char*);
SOAP_FMAC3 struct ns__Response ** SOAP_FMAC4 soap_get_PointerTons__Response(struct soap*, struct ns__Response **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTons__HBNET_CAMERA_PTZCTRL_DEFINED
#define SOAP_TYPE_PointerTons__HBNET_CAMERA_PTZCTRL_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons__HBNET_CAMERA_PTZCTRL(struct soap*, struct ns__HBNET_CAMERA_PTZCTRL *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons__HBNET_CAMERA_PTZCTRL(struct soap*, const char *, int, struct ns__HBNET_CAMERA_PTZCTRL *const*, const char *);
SOAP_FMAC3 struct ns__HBNET_CAMERA_PTZCTRL ** SOAP_FMAC4 soap_in_PointerTons__HBNET_CAMERA_PTZCTRL(struct soap*, const char*, struct ns__HBNET_CAMERA_PTZCTRL **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons__HBNET_CAMERA_PTZCTRL(struct soap*, struct ns__HBNET_CAMERA_PTZCTRL *const*, const char*, const char*);
SOAP_FMAC3 struct ns__HBNET_CAMERA_PTZCTRL ** SOAP_FMAC4 soap_get_PointerTons__HBNET_CAMERA_PTZCTRL(struct soap*, struct ns__HBNET_CAMERA_PTZCTRL **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerTons__HBNET_VIDEO_STREAM_DEFINED
#define SOAP_TYPE_PointerTons__HBNET_VIDEO_STREAM_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons__HBNET_VIDEO_STREAM(struct soap*, struct ns__HBNET_VIDEO_STREAM *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons__HBNET_VIDEO_STREAM(struct soap*, const char *, int, struct ns__HBNET_VIDEO_STREAM *const*, const char *);
SOAP_FMAC3 struct ns__HBNET_VIDEO_STREAM ** SOAP_FMAC4 soap_in_PointerTons__HBNET_VIDEO_STREAM(struct soap*, const char*, struct ns__HBNET_VIDEO_STREAM **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons__HBNET_VIDEO_STREAM(struct soap*, struct ns__HBNET_VIDEO_STREAM *const*, const char*, const char*);
SOAP_FMAC3 struct ns__HBNET_VIDEO_STREAM ** SOAP_FMAC4 soap_get_PointerTons__HBNET_VIDEO_STREAM(struct soap*, struct ns__HBNET_VIDEO_STREAM **, const char*, const char*);
#endif
/* _xsd__schema is a typedef synonym for _XML */

#ifndef SOAP_TYPE__xsd__schema_DEFINED
#define SOAP_TYPE__xsd__schema_DEFINED
#endif

#ifndef SOAP_TYPE__XML_DEFINED
#define SOAP_TYPE__XML_DEFINED
#endif

#ifndef SOAP_TYPE__QName_DEFINED
#define SOAP_TYPE__QName_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default__QName(struct soap*, char **);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap*, char *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap*, const char*, int, char*const*, const char*);
SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap*, const char*, char **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap*, char *const*, const char*, const char*);

inline int soap_write__QName(struct soap *soap, char *const *p)
{	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || soap_put__QName(soap, p, "QName", NULL) || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}
SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap*, char **, const char*, const char*);

inline int soap_read__QName(struct soap *soap, char **p)
{	if (p)
	{	if (soap_begin_recv(soap) || soap_get__QName(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_string_DEFINED
#define SOAP_TYPE_string_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap*, char **);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap*, char *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap*, const char*, int, char*const*, const char*);
SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap*, const char*, char **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap*, char *const*, const char*, const char*);

inline int soap_write_string(struct soap *soap, char *const *p)
{	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || soap_put_string(soap, p, "string", NULL) || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}
SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap*, char **, const char*, const char*);

inline int soap_read_string(struct soap *soap, char **p)
{	if (p)
	{	if (soap_begin_recv(soap) || soap_get_string(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}
#endif

#endif

/* End of soapH.h */
